<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tree Planting Map</title>
    <link href='https://api.mapbox.com/mapbox-gl-js/v2.10.0/mapbox-gl.css' rel='stylesheet' />
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.1/css/all.css">
    <style>
        body {
            display: flex;
            font-family: 'Arial', sans-serif;
            margin:0px;
        }
        #sidebar {
            width: 300px;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            background-color: #f4f4f4;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        }
        #map {
            height: 100vh;
            flex-grow: 1;
        }
        .input-group {
            margin: 15px 0;
            display: flex;
            flex-direction: column;
        }
        .input-group label {
            margin-bottom: 5px;
            font-weight: bold;
        }
        .input-group input {
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 5px;
        }
        button {
            margin-top:10px;
            padding: 10px 20px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        button:hover {
            background-color: #45a049;
        }

        /* Style for the custom checkbox */
        .custom-checkbox {
            display: inline-block;
            position: relative;
            padding-left: 25px;
            cursor: pointer;
            font-size: 16px;
            line-height: 20px;
            user-select: none;
        }

        /* Hide the default checkbox */
        .custom-checkbox input {
            position: absolute;
            opacity: 0;
            cursor: pointer;
            height: 0;
            width: 0;
        }

        /* Create a custom checkbox */
        .checkmark {
            position: absolute;
            top: 0;
            left: 0;
            height: 20px;
            width: 20px;
            background-color: #eee;
            border-radius: 4px;
        }

        /* When the checkbox is checked, add a blue background */
        .custom-checkbox input:checked ~ .checkmark {
            background-color: #2196F3;
        }

        /* Create the checkmark/indicator (hidden when not checked) */
        .checkmark:after {
            content: "\f00c"; /* Correct code for FontAwesome checkmark */
            font-family: "Font Awesome 5 Free";
            font-weight: 900; /* FontAwesome 5 requires explicit font-weight for solid icons */
            position: absolute;
            display: none;
            color: white;
            top: -2px;
            left: 5px;
            font-size: 14px;
        }

        /* Show the checkmark when checked */
        .custom-checkbox input:checked ~ .checkmark:after {
            display: block;
        }

        /* Style the checkmark/indicator */
        .custom-checkbox .checkmark:after {
            left: 5px;
            top: 0px;
        }

        .district-label-tooltip {
            background-color: transparent;
            border: none;
            box-shadow: none;
            font-size: 14px;
            color: black;
            text-align: center;
            padding: 0;
            pointer-events: none;
            z-index: 1000000;
        }

        .district-label {
            font-weight: normal;
            z-index: 1000000;
        }
    </style>
</head>
<body>

    <div id="sidebar">
        <h2><i class="fas fa-tree"></i> Tree Planting Parameters</h2>
        <form id="parametersForm">
            <div class="input-group">
                <label for="boroSelect">Select Borough:</label>
                <select id="boroSelect" data-current="">
                    <!-- Options will be dynamically added -->
                </select>
            </div>

            <div class="input-group">
                <label for="totalTrees">Total Trees:</label>
                <input type="number" id="totalTrees" name="totalTrees" value="100">
            </div>
            <div class="input-group">
                <label for="coolingEffect">Cooling Effect:</label>
                <input type="number" id="coolingEffect" name="coolingEffect" step="1" value="1">
            </div>
            <div class="input-group">
                <label for="coolingDistance">Cooling Distance (meters):</label>
                <input type="number" id="coolingDistance" name="coolingDistance" value="200">
            </div>
            <button type="button" onclick="updateTreePlanting()">Update Tree Planting</button>
            <button type="button" onclick="clearPlantedTrees()">Clear Planted Trees</button>
            <h4 id="results">...</h4>

            <div class="input-group">
                <label>Effect Type:</label>
                <label><input type="radio" name="effectType" value="binary" onchange="toggleGaussianSettings()" checked> Binary</label>
                <label><input type="radio" name="effectType" value="gaussian" onchange="toggleGaussianSettings()"> Gaussian</label>
            </div>
            <div id="gaussianSettings" style="display: none;">
                <div class="input-group">
                    <label for="gaussianSigma">Gaussian Sigma:</label>
                    <input type="number" id="gaussianSigma" name="gaussianSigma" step="0.1" value="1">
                </div>
                <div class="input-group">
                    <label for="gaussianAmplitude">Gaussian Amplitude:</label>
                    <input type="number" id="gaussianAmplitude" name="gaussianAmplitude" step="0.1" value="1">
                </div>
            </div>

            <label class="custom-checkbox">Show Heat Index
                <input type="checkbox" id="heatIndexToggle" name="heatIndexToggle" onchange="toggleHeatIndex()" checked>
                <span class="checkmark"></span>
            </label>
            <div id="heatIndexSettings" style="display: none;">
                <div class="input-group" style="display: none;">
                    <label for="heatIndexScale">Heat Index Scale:</label>
                    <input type="range" id="heatIndexScale" name="heatIndexScale" min="0.1" max="10" step="0.1" value="1">
                </div>
            </div>

            <!-- Tree Data Toggle and Settings -->
            <label class="custom-checkbox">View Tree Data
                <input type="checkbox" id="treeToggleView" name="treeToggleView" onchange="toggleTreeSettings()">
                <span class="checkmark"></span>
            </label>
            <div id="treeSettings" style="display: none;">
                <label class="custom-checkbox">Show Tree Radius
                    <input type="checkbox" id="treeRadiusToggle" name="treeRadiusToggle" onchange="toggleTreeRadius()" checked>
                    <span class="checkmark"></span>
                </label>
                <div class="input-group">
                    <label for="treeCoolingEffect">Tree Cooling Effect:</label>
                    <input type="number" id="treeCoolingEffect" name="treeCoolingEffect" step="0.1" value="0.1">
                </div>
                <div class="input-group">
                    <label for="treeCoolingDistance">Tree Cooling Distance (meters):</label>
                    <input type="number" id="treeCoolingDistance" name="treeCoolingDistance" value="20">
                </div>
            </div>

            <!-- School Data Toggle and Settings -->
            <label class="custom-checkbox">View School Data
                <input type="checkbox" id="schoolToggleView" name="schoolToggleView" onchange="toggleSchoolSettings()">
                <span class="checkmark"></span>
            </label>
            <div id="schoolSettings" style="display: none;">
                <label class="custom-checkbox">Show School Radius
                    <input type="checkbox" id="schoolRadiusToggle" name="schoolRadiusToggle" onchange="toggleSchoolRadius()" checked>
                    <span class="checkmark"></span>
                </label>
                <div class="input-group">
                    <label for="schoolHeatingEffect">School Heating Effect:</label>
                    <input type="number" id="schoolHeatingEffect" name="schoolHeatingEffect" step="0.1" value="0.1">
                </div>
                <div class="input-group">
                    <label for="schoolHeatingDistance">School Heating Distance (meters):</label>
                    <input type="number" id="schoolHeatingDistance" name="schoolHeatingDistance" value="200">
                </div>
            </div>

            <!-- Facility Data Toggle and Settings -->
            <label class="custom-checkbox">View Facility Data
                <input type="checkbox" id="facilityToggleView" name="facilityToggleView" onchange="toggleFacilitySettings()">
                <span class="checkmark"></span>
            </label>
            <div id="facilitySettings" style="display: none;">
                <label class="custom-checkbox">Show Facility Radius
                    <input type="checkbox" id="facilityRadiusToggle" name="facilityRadiusToggle" onchange="toggleFacilityRadius()" checked>
                    <span class="checkmark"></span>
                </label>
                <div class="input-group">
                    <label for="facilityHeatingEffect">Facility Heating Effect:</label>
                    <input type="number" id="facilityHeatingEffect" name="facilityHeatingEffect" step="0.1" value="0.1">
                </div>
                <div class="input-group">
                    <label for="facilityHeatingDistance">Facility Heating Distance (meters):</label>
                    <input type="number" id="facilityHeatingDistance" name="facilityHeatingDistance" value="60">
                </div>
            </div>

            <!-- Add the following in the sidebar section of the HTML -->
            <label class="custom-checkbox">View Street Data
                <input type="checkbox" id="streetToggleView" name="streetToggleView" onchange="toggleStreetSettings()">
                <span class="checkmark"></span>
            </label>
            <div id="streetSettings" style="display: none;">
                <label class="custom-checkbox">Show Street Buffer
                    <input type="checkbox" id="streetBufferToggle" name="streetBufferToggle" onchange="toggleStreetBuffer()" checked>
                    <span class="checkmark"></span>
                </label>
                <div class="input-group">
                    <label for="streetEffect">Street Effect:</label>
                    <input type="number" id="streetEffect" name="streetEffect" step="0.1" value="0.1">
                </div>
                <div class="input-group">
                    <label for="streetBufferDistance">Street Buffer Distance (meters):</label>
                    <input type="number" id="streetBufferDistance" name="streetBufferDistance" value="5">
                </div>
                <div class="input-group">
                    <label for="streetWeightField">Street Weight Field:</label>
                    <select id="streetWeightField" name="streetWeightField">
                        <option value="SHAPE_Leng">SHAPE_Leng</option>
                        <option value="BoroCode">BoroCode</option>
                        <option value="BoroName">BoroName</option>
                        <option value="BoroCD">BoroCD</option>
                        <option value="CounDist">CounDist</option>
                        <option value="AssemDist">AssemDist</option>
                        <option value="StSenDist">StSenDist</option>
                        <option value="CongDist">CongDist</option>
                        <option value="Rank">Rank</option>
                        <option value="PMP_ID">PMP_ID</option>
                        <option value="NTA2020">NTA2020</option>
                        <option value="Category">Category</option>
                        <option value="NTAName">NTAName</option>
                        <option value="FEMAFldz">FEMAFldz</option>
                        <option value="FEMAFldT">FEMAFldT</option>
                        <option value="HrcEvac">HrcEvac</option>
                    </select>
                </div>                
            </div>

            <label class="custom-checkbox">Planting View
                <input type="checkbox" id="plantingViewToggle" name="plantingViewToggle">
                <span class="checkmark"></span>
            </label>
        </form>
    </div>
    
    <div id="map"></div>

    <script src='https://api.mapbox.com/mapbox-gl-js/v2.10.0/mapbox-gl.js'></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>
    <script src="shp.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/rbush@3.0.1/rbush.min.js"></script>

    <script>
        mapboxgl.accessToken = 'pk.eyJ1IjoicnlhbmhsZXdpcyIsImEiOiJjbDhkcWZzcHowbGhiM3VrOWJ3ZmtzcnZyIn0.ipWAZK-oipctMjaHytOUKQ';

        var map = new mapboxgl.Map({
            container: 'map',
            style: 'mapbox://styles/mapbox/light-v10',
            center: [-73.930188, 40.642935],
            zoom: 13
        });

        // load in treefolio84.geojson to originalGeoJsonData
        

        map.on('load', function () {

            map.addSource('boroughs', {
                type: 'geojson',
                // data: 'boroboundaries.geojson' // Replace with the path to your GeoJSON file
                // boroboundaries_with_id.geojson
                data: 'boroboundaries_with_id.geojson'
            });

            // Add a layer to display the boroughs
            map.addLayer({
                id: 'boroughs',
                type: 'fill',
                source: 'boroughs',
                paint: {
                    // 'fill-color': '#888888',
                    'fill-opacity': 0
                }
            });

            // Add a layer for the borough borders
            map.addLayer({
                id: 'borough-borders',
                type: 'line',
                source: 'boroughs',
                paint: {
                    'line-color': '#000000',
                    'line-width': 2
                }
            });

            map.on('mousemove', 'boroughs', function(e) {
    if (e.features.length > 0) {
        var selectedBorough = document.getElementById('boroSelect').getAttribute('data-current');
        var hoveredBorough = e.features[0].properties.boro_cd;

        if (hoveredStateId !== null) {
            map.setFeatureState({ source: 'boroughs', id: hoveredStateId }, { hover: false });
        }

        if (selectedBorough !== hoveredBorough.toString()) {
            hoveredStateId = e.features[0].id;
            map.setFeatureState({ source: 'boroughs', id: hoveredStateId }, { hover: true });
        } else {
            hoveredStateId = null; // Reset if the hovered borough is the selected one
        }
    }
});

map.on('click', 'boroughs', function(e) {
    var selectedBorough = e.features[0].properties.boro_cd;

    // document.getElementById('boroSelect').setAttribute('data-current', selectedBorough);
    document.getElementById('boroSelect').value = selectedBorough;
    switchBorough();
    map.fitBounds(turf.bbox(e.features[0]));

    if (hoveredStateId !== null) {
        map.setFeatureState({ source: 'boroughs', id: hoveredStateId }, { hover: false });
    }
    hoveredStateId = e.features[0].id;
    map.setFeatureState({ source: 'boroughs', id: hoveredStateId }, { hover: true });
});

map.on('mouseleave', 'boroughs', function() {
    if (hoveredStateId !== null) {
        map.setFeatureState({ source: 'boroughs', id: hoveredStateId }, { hover: false });
    }
    hoveredStateId = null;
});

// Disable hover for the selected borough
map.on('mouseenter', 'boroughs', function(e) {
    var selectedBorough = document.getElementById('boroSelect').getAttribute('data-current');
    var hoveredBorough = e.features[0].properties.boro_cd;

    if (selectedBorough === hoveredBorough.toString()) {
        map.getCanvas().style.cursor = 'grab';
    } else {
        map.getCanvas().style.cursor = 'pointer';
    }
});

map.on('mouseleave', 'boroughs', function() {
    map.getCanvas().style.cursor = '';
});


            // Add feature state for hover effect
            map.addLayer({
                id: 'boroughs-hover',
                type: 'fill',
                source: 'boroughs',
                layout: {},
                paint: {
                    'fill-color': '#627BC1',
                    'fill-opacity': ['case', ['boolean', ['feature-state', 'hover'], false], 0.6, 0]
                }
            });

            var hoveredStateId = null;

            // Add your GeoJSON source for tree markers
            map.addSource('treeMarkers', {
                type: 'geojson',
                data: {
                    type: 'FeatureCollection',
                    features: []
                }
            });

            // Add a layer to display the tree markers
            map.addLayer({
                id: 'treeMarkers',
                type: 'circle',
                source: 'treeMarkers',
                paint: {
                    'circle-radius': 5,
                    'circle-color': '#ADD8E6',
                    // green instead
                    'circle-color': '#008000',
                    'circle-opacity': 0.8
                }
            });
            // Add your GeoJSON source
            map.addSource('plantableAreas', {
                type: 'geojson',
                data: 'inputStreet.geojson'
            });

            // Add a layer to use the image to represent the data.
            map.addLayer({
                id: 'plantableAreas',
                type: 'fill',
                source: 'plantableAreas',
                layout: {},
                paint: {
                    'fill-color': [
                        'case',
                        ['==', ['get', 'canopy_type'], 'plantable'],
                        ['get', 'color'],
                        '#ffffff'
                    ],
                    'fill-opacity': 0.5
                }
            });

            map.addSource('schoolLayer', {
    type: 'geojson',
    data: {
        type: 'FeatureCollection',
        features: []
    }
});

map.addSource('treeLayer', {
    type: 'geojson',
    data: {
        type: 'FeatureCollection',
        features: []
    }
});

map.addLayer({
    id: 'schoolLayer',
    type: 'circle',
    source: 'schoolLayer',
    paint: {
        'circle-radius': 5,
        'circle-color': '#FF0000',
        'circle-opacity': 0.8
    }
});

map.addLayer({
    id: 'treeLayer',
    type: 'circle',
    source: 'treeLayer',
    paint: {
        'circle-radius': 5,
        'circle-color': '#00FF00',
        'circle-opacity': 0.8
    }
});

map.addSource('treesLayer', {
        type: 'geojson',
        data: {
            type: 'FeatureCollection',
            features: []
        }
    });

    map.addLayer({
        id: 'treesLayer',
        type: 'circle',
        source: 'treesLayer',
        paint: {
            'circle-radius': 5,
            'circle-color': '#00FF00',
            'circle-opacity': 0.8
        }
    });

 // Add source for facilities
 map.addSource('facilityLayer', {
        type: 'geojson',
        data: {
            type: 'FeatureCollection',
            features: []
        }
    });

    // Add layer for facilities
    map.addLayer({
        id: 'facilityLayer',
        type: 'circle',
        source: 'facilityLayer',
        paint: {
            'circle-radius': 5,
            'circle-color': '#0000FF', // Blue color
            'circle-opacity': 0.8
        }
    });

    // Facility radius circle layer
    map.addSource('facilityCirclesLayer', {
        type: 'geojson',
        data: {
            type: 'FeatureCollection',
            features: []
        }
    });

    map.addLayer({
        id: 'facilityCirclesLayer',
        type: 'line',
        source: 'facilityCirclesLayer',
        paint: {
            'line-color': '#0000FF', // Blue color
            'line-width': 2
        }
    });

// Add source for streets
map.addSource('streetLayer', {
    type: 'geojson',
    data: {
        type: 'FeatureCollection',
        features: []
    }
});

map.addLayer({
    id: 'streetLayer',
    type: 'line',
    source: 'streetLayer',
    paint: {
        'line-color': 'gray',
        'line-width': 2,
        'line-opacity': 0.7
    }
});

map.addSource('streetBuffersLayer', {
    type: 'geojson',
    data: {
        type: 'FeatureCollection',
        features: []
    }
});

map.addLayer({
    id: 'streetBuffersLayer',
    type: 'fill',
    source: 'streetBuffersLayer',
    paint: {
        'fill-color': 'blue',
        'fill-opacity': 0.2
    }
});

    document.getElementById('treeToggleView').addEventListener('change', toggleTreeSettings);
    document.getElementById('treeRadiusToggle').addEventListener('change', toggleTreeRadius);


    // Add event listeners for school settings
    document.getElementById('schoolHeatingEffect').addEventListener('change', updatePlantableAreaColors);
    document.getElementById('schoolHeatingDistance').addEventListener('change', function() {
        updateSchoolHeatingDistance();
        updatePlantableAreaColors();
    });
    document.getElementById('schoolToggleView').addEventListener('change', toggleSchoolSettings);
    document.getElementById('schoolRadiusToggle').addEventListener('change', toggleSchoolRadius);
            // Call the function to update tree planting parameters
            // updateTreePlanting();
        });

        var currentGeoJsonLayer = null;

        // Make a layer for the trees, schools, and facilities using Mapbox GL JS
        // var newLayer = new mapboxgl.LayerGroup(); // Initialize with an empty layer group
        

        function displayGeoJson(geojsonData) {
            if (map.getSource('plantableAreas')) {
        map.getSource('plantableAreas').setData(geojsonData);
    } else {
        console.error('Source "plantableAreas" is not defined');
    }
        }

        function updateTreePlanting() {
    var totalTrees = parseInt(document.getElementById('totalTrees').value);
    var coolingEffect = parseFloat(document.getElementById('coolingEffect').value);
    var coolingDistance = parseInt(document.getElementById('coolingDistance').value);

    // Clear existing tree markers
    clearMapLayers();

    let schoolEffect = parseFloat(document.getElementById('schoolHeatingEffect').value);
    let schoolDistance = parseInt(document.getElementById('schoolHeatingDistance').value);
    let treeEffect = parseFloat(document.getElementById('treeCoolingEffect').value);
    let treeDistance = parseInt(document.getElementById('treeCoolingDistance').value);
    let facilityEffect = parseFloat(document.getElementById('facilityHeatingEffect').value);
    let facilityDistance = parseInt(document.getElementById('facilityHeatingDistance').value);
    let streetEffect = parseFloat(document.getElementById('streetEffect').value);
    let streetBufferDistance = parseInt(document.getElementById('streetBufferDistance').value);
    let streetWeightField = document.getElementById('streetWeightField').value;

    PlantTrees(originalGeoJsonData, totalTrees, coolingEffect, coolingDistance, schoolEffect, schoolDistance, treeEffect, treeDistance, facilityEffect, facilityDistance, streetEffect, streetBufferDistance, streetWeightField);
}


        function clearMapLayers() {
    console.log('Clearing map layers');

    schoolCircles.forEach(function(schoolCircle) {
        console.log('Removing school circle layer:', schoolCircle);
        if (map.getLayer(schoolCircle.id)) {
            map.removeLayer(schoolCircle.id);
        }
        if (map.getSource(schoolCircle.id)) {
            map.removeSource(schoolCircle.id);
        }

        const pointId = 'schoolPoint_' + schoolCircle.id;
        if (map.getLayer(pointId)) {
            map.removeLayer(pointId);
        }
        if (map.getSource(pointId)) {
            map.removeSource(pointId);
        }
    });

    schoolCircles = [];
}

        function clearPlantedTrees() {
                // Clear the treeMarkers source
    if (map.getSource('treeMarkers')) {
        map.getSource('treeMarkers').setData({
            type: 'FeatureCollection',
            features: []
        });
    }
            document.getElementById('results').innerText = 'Cleared all planted trees.';
        }


        function calculateCentroid(geometry) {
            let centroid = [0, 0];
            let totalPoints = 0;

            if (geometry.type === "Polygon") {
                geometry.coordinates[0].forEach(coord => {
                    centroid[0] += coord[0]; // longitude
                    centroid[1] += coord[1]; // latitude
                    totalPoints++;
                });
            } else if (geometry.type === "MultiPolygon") {
                geometry.coordinates.forEach(polygon => {
                    let polygonCentroid = [0, 0];
                    let polygonPoints = 0;
                    polygon[0].forEach(coord => { // Only using the first ring
                        polygonCentroid[0] += coord[0];
                        polygonCentroid[1] += coord[1];
                        polygonPoints++;
                    });
                    centroid[0] += polygonCentroid[0] / polygonPoints; // Average for this polygon
                    centroid[1] += polygonCentroid[1] / polygonPoints;
                    totalPoints += 1; // We're averaging centroids, so each polygon counts as one "point"
                });
            }

            centroid[0] /= totalPoints; // Final average
            centroid[1] /= totalPoints;
            return [centroid[1], centroid[0]]; // Mapbox uses [lat, lng] format
        }

        function PlantTrees(originalGeoJsonData, totalTrees, coolingEffect, coolingDistance, schoolEffect, schoolDistance, treeEffect, treeDistance, facilityEffect, facilityDistance, streetEffect, streetBufferDistance, streetWeightField) {
    let geojsonData = JSON.parse(JSON.stringify(originalGeoJsonData));

    // Apply effects from schools, trees, facilities, and streets
    geojsonData = applySchoolEffect(geojsonData, schoolEffect, schoolDistance);
    geojsonData = applyTreeEffect(geojsonData, treeEffect, treeDistance);
    geojsonData = applyFacilityEffect(geojsonData, facilityEffect, facilityDistance);
    geojsonData = applyStreetEffect(geojsonData, streetEffect, streetBufferDistance, streetWeightField);

    let plantableAreas = geojsonData.features.filter(feature => feature.properties.canopy_type === 'plantable');

    let treesPlanted = 0;

    while (treesPlanted < totalTrees && plantableAreas.length > 0) {
        // Calculate the combined mean for each plantable area
        plantableAreas.forEach(area => {
            area.properties._combinedMean = (area.properties._mean || 0) + 
                                             (area.properties._schoolmean || 0) + 
                                             (area.properties._treemean || 0) + 
                                             (area.properties._facilitymean || 0) + 
                                             (area.properties._streetmean || 0);
        });

        // Sort plantable areas by _combinedMean property in descending order
        plantableAreas.sort((a, b) => b.properties._combinedMean - a.properties._combinedMean);

        const plantingArea = plantableAreas[0];
        const centroid = calculateCentroid(plantingArea.geometry);

        placeTreeOnMap(centroid);
        treesPlanted++;

        // Apply cooling effect to the planted area if applicable
        if (coolingEffect > 0) {
            plantingArea.properties._treemean = (plantingArea.properties._treemean || 0) - coolingEffect;
            plantingArea.properties._displayMean = (plantingArea.properties._mean || 0) + 
                                                    (plantingArea.properties._schoolmean || 0) + 
                                                    (plantingArea.properties._treemean || 0) + 
                                                    (plantingArea.properties._facilitymean || 0) + 
                                                    (plantingArea.properties._streetmean || 0);
        }

        // Filter and adjust remaining plantable areas considering cooling effect and distance
        plantableAreas = plantableAreas.slice(1).filter(area => {
            const areaCentroid = calculateCentroid(area.geometry);
            const distance = getDistance(centroid[0], centroid[1], areaCentroid[0], areaCentroid[1]);
            if (coolingDistance > 0 && distance <= coolingDistance && coolingEffect > 0) {
                area.properties._treemean = (area.properties._treemean || 0) - coolingEffect * (coolingDistance - distance) / coolingDistance;
                area.properties._displayMean = (area.properties._mean || 0) + 
                                               (area.properties._schoolmean || 0) + 
                                               (area.properties._treemean || 0) + 
                                               (area.properties._facilitymean || 0) + 
                                               (area.properties._streetmean || 0);
            }
            return area.properties._combinedMean > 0;
        });
    }

    if (treesPlanted < totalTrees) {
        console.log(`Planted ${treesPlanted} trees. Ran out of suitable planting areas.`);
        document.getElementById('results').innerText = `Planted ${treesPlanted} trees. Ran out of suitable planting areas.`;
    } else {
        console.log(`Successfully planted all ${totalTrees} trees.`);
        document.getElementById('results').innerText = `Successfully planted all ${totalTrees} trees.`;
    }

    if (document.getElementById('plantingViewToggle').checked) {
        calculateMinMaxMean(geojsonData);
        updateMeanColors(geojsonData);
        displayGeoJson(geojsonData);
    }
}


        function placeTreeOnMap(centroid) {
            const treeMarkerSource = map.getSource('treeMarkers');
            const newFeature = {
                type: 'Feature',
                geometry: {
                    type: 'Point',
                    coordinates: [centroid[1], centroid[0]]
                },
                properties: {}
            };

            const data = treeMarkerSource._data; // Access the current data
            data.features.push(newFeature); // Add the new feature
            treeMarkerSource.setData(data); // Update the source with the new data
        }


        function getDistance(lat1, lon1, lat2, lon2) {
            var R = 6371e3; // Earth's radius in meters
            var φ1 = lat1 * Math.PI / 180;
            var φ2 = lat2 * Math.PI / 180;
            var Δφ = (lat2 - lat1) * Math.PI / 180;
            var Δλ = (lon2 - lon1) * Math.PI / 180;

            var a = Math.sin(Δφ / 2) * Math.sin(Δφ / 2) +
                    Math.cos(φ1) * Math.cos(φ2) *
                    Math.sin(Δλ / 2) * Math.sin(Δλ / 2);
            var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

            return R * c; // in meters
        }

        function getColor(heatIndex, scale) {
            console.log("max and min mean", maxMean, minMean);
            const range = maxMean - minMean;
            const normalizedIndex = (heatIndex - minMean) / range;
            const scaledIndex = Math.pow(normalizedIndex, scale);

            // Interpolate between green (0), orange (0.5), and red (1)
            if (scaledIndex < 0.5) {
                // Mix between green and orange
                const mix = scaledIndex * 2;
                return mixColor('#008000', '#ff8c00', mix);
            } else {
                // Mix between orange and red
                const mix = (scaledIndex - 0.5) * 2;
                return mixColor('#ff8c00', '#ff0000', mix);
            }
        }

        var showHeatIndex = false;
        var heatIndexScale = 1;

        function toggleHeatIndex() {
            showHeatIndex = document.getElementById('heatIndexToggle').checked;
            console.log("Show heat index:", showHeatIndex);
            document.getElementById('heatIndexSettings').style.display = showHeatIndex ? 'block' : 'none';
            updatePlantableAreaColors();
        }

        function mixColor(color1, color2, weight) {
            var color1Rgb = hexToRgb(color1),
                color2Rgb = hexToRgb(color2),
                r = Math.round(mix(color1Rgb.r, color2Rgb.r, weight)),
                g = Math.round(mix(color1Rgb.g, color2Rgb.g, weight)),
                b = Math.round(mix(color1Rgb.b, color2Rgb.b, weight));
            return rgbToHex(r, g, b);
        }

        function mix(start, end, weight) {
            return start + (end - start) * weight;
        }

        function hexToRgb(hex) {
            var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : null;
        }

        function rgbToHex(r, g, b) {
            return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
        }

        var originalGeoJsonData;

        var minMean, maxMean;

        function calculateMinMaxMean(geojsonData) {
            var means = geojsonData.features.map(feature => {
                if (feature.properties.canopy_type === 'plantable') {
                    return feature.properties._displayMean;
                }
            }).filter(mean => mean !== undefined);

            minMean = Math.min(...means);
            maxMean = Math.max(...means);
            if (minMean === maxMean) {
                minMean = 0;
                maxMean = 1;
            }
            if (minMean === Infinity) {
                minMean = 0;
                maxMean = 1;
            }
            console.log("Calculated min and max mean values:", minMean, maxMean);
        }

        function drawLinesToClosestSchoolFromLayer() {
            originalGeoJsonData.features.forEach(plantableArea => {
                if (plantableArea.properties.canopy_type === 'plantable') {
                    const plantableCentroid = calculateCentroid(plantableArea.geometry);

                    let closestSchoolPoint = null;
                    let minDistance = Infinity;

                    schoolLayer.eachLayer(function(layer) {
                        let schoolPoint;
                        if (layer.feature && layer.feature.geometry) {
                            if (layer.feature.geometry.type === 'MultiPoint') {
                                const firstPointCoords = layer.feature.geometry.coordinates[0];
                                schoolPoint = [firstPointCoords[1], firstPointCoords[0]]; // Correct [lat, lng] order for Mapbox
                            } else {
                                schoolPoint = [layer.feature.geometry.coordinates[1], layer.feature.geometry.coordinates[0]];
                            }
                        } else if (layer.getLatLng) {
                            let latLng = layer.getLatLng();
                            schoolPoint = [latLng.lat, latLng.lng];
                        } else {
                            console.log('Unknown layer type or geometry not defined');
                            return;
                        }

                        const distance = getDistance(plantableCentroid[0], plantableCentroid[1], schoolPoint[0], schoolPoint[1]);
                        if (distance < minDistance) {
                            closestSchoolPoint = schoolPoint;
                            minDistance = distance;
                        }
                    });

                    if (closestSchoolPoint) {
                        map.addLayer({
                            id: 'line' + Math.random(),
                            type: 'line',
                            source: {
                                type: 'geojson',
                                data: {
                                    type: 'Feature',
                                    geometry: {
                                        type: 'LineString',
                                        coordinates: [
                                            [plantableCentroid[1], plantableCentroid[0]],
                                            closestSchoolPoint
                                        ]
                                    }
                                }
                            },
                            layout: {
                                'line-join': 'round',
                                'line-cap': 'round'
                            },
                            paint: {
                                'line-color': 'blue',
                                'line-width': 1,
                                'line-opacity': 0.5
                            }
                        });
                    }
                }
            });
        }

        function updatePlantableAreaColors() {
    // Clone the original GeoJSON data to avoid modifying it directly
    let geojsonData = JSON.parse(JSON.stringify(originalGeoJsonData));

    // Apply the necessary effects
    let schoolEffect = parseFloat(document.getElementById('schoolHeatingEffect').value);
    let schoolDistance = parseInt(document.getElementById('schoolHeatingDistance').value);
    let treeEffect = parseFloat(document.getElementById('treeCoolingEffect').value);
    let treeDistance = parseInt(document.getElementById('treeCoolingDistance').value);
    let facilityEffect = parseFloat(document.getElementById('facilityHeatingEffect').value);
    let facilityDistance = parseInt(document.getElementById('facilityHeatingDistance').value);
    let streetEffect = parseFloat(document.getElementById('streetEffect').value);
    let streetBufferDistance = parseInt(document.getElementById('streetBufferDistance').value);
    let streetWeightField = document.getElementById('streetWeightField').value;

    geojsonData = applySchoolEffect(geojsonData, schoolEffect, schoolDistance);
    geojsonData = applyTreeEffect(geojsonData, treeEffect, treeDistance);
    geojsonData = applyFacilityEffect(geojsonData, facilityEffect, facilityDistance);
    geojsonData = applyStreetEffect(geojsonData, streetEffect, streetBufferDistance, streetWeightField);

    // Calculate _displayMean based on the selected options and apply it to existing means
    geojsonData.features.forEach(feature => {
        if (feature.properties.canopy_type === 'plantable') {
            let currentMean = feature.properties._mean || 0;
            let schoolMean = feature.properties._schoolmean || 0;
            let treeMean = feature.properties._treemean || 0;
            let facilityMean = feature.properties._facilitymean || 0;
            let streetMean = feature.properties._streetmean || 0;

            if (document.getElementById('heatIndexToggle').checked) {
                feature.properties._displayMean = currentMean + schoolMean + treeMean + facilityMean + streetMean;
            } else {
                feature.properties._displayMean = schoolMean + treeMean + facilityMean + streetMean;
            }
        }
    });

    calculateMinMaxMean(geojsonData);
    updateMeanColors(geojsonData);
    displayGeoJson(geojsonData);
}




        function getMeanColor(mean) {
            const normalizedMean = (mean - minMean) / (maxMean - minMean);
            if (normalizedMean < 0.5) {
                const mix = normalizedMean * 2;
                return mixColor('#008000', '#ff8c00', mix);
            } else {
                const mix = (normalizedMean - 0.5) * 2;
                return mixColor('#ff8c00', '#ff0000', mix);
            }
        }

        function updateMeanColors(geojsonData) {
            geojsonData.features.forEach(feature => {
                if (feature.properties.canopy_type === 'plantable') {
                    const mean = feature.properties._displayMean;
                    feature.properties.color = getMeanColor(mean);
                }
            });
        }

        function applyFacilityEffect(geojsonData, facilityEffect, facilityDistance) {
    if (!document.getElementById('facilityToggleView').checked) {
        return geojsonData;
    }

    var effectType = document.querySelector('input[name="effectType"]:checked').value;
    var sigma = parseFloat(document.getElementById('gaussianSigma').value);
    var amplitude = parseFloat(document.getElementById('gaussianAmplitude').value);
    
    var facilityLayer = map.getSource('facilityLayer')._data;

    geojsonData.features.forEach(plantableArea => {
        if (plantableArea.properties.canopy_type === 'plantable') {
            const plantableCentroid = calculateCentroid(plantableArea.geometry);

            facilityLayer.features.forEach(facilityFeature => {
                const facilityPoint = facilityFeature.geometry.coordinates;

                const distance = getDistance(plantableCentroid[0], plantableCentroid[1], facilityPoint[1], facilityPoint[0]);
                if (effectType === 'binary') {
                    if (distance <= facilityDistance) {
                        if (!plantableArea.properties._facilitymean) {
                            plantableArea.properties._facilitymean = 0;
                        }
                        plantableArea.properties._facilitymean += facilityEffect;
                    }
                } else if (effectType === 'gaussian') {
                    var weight = gaussianWeight(distance, facilityDistance, sigma, amplitude);
                    if (!plantableArea.properties._facilitymean) {
                        plantableArea.properties._facilitymean = 0;
                    }
                    plantableArea.properties._facilitymean += facilityEffect * weight;
                }
            });
        }
    });
    return geojsonData;
}


        function applySchoolEffect(geojsonData, schoolEffect, schoolDistance) {
    if (!document.getElementById('schoolToggleView').checked) {
        return geojsonData;
    }

    var effectType = document.querySelector('input[name="effectType"]:checked').value;
    var sigma = parseFloat(document.getElementById('gaussianSigma').value);
    var amplitude = parseFloat(document.getElementById('gaussianAmplitude').value);
    
    var schoolLayer = map.getSource('schoolLayer')._data;

    geojsonData.features.forEach(plantableArea => {
        if (plantableArea.properties.canopy_type === 'plantable') {
            const plantableCentroid = calculateCentroid(plantableArea.geometry);

            schoolLayer.features.forEach(schoolFeature => {
                const schoolPoint = schoolFeature.geometry.coordinates;

                const distance = getDistance(plantableCentroid[0], plantableCentroid[1], schoolPoint[1], schoolPoint[0]);
                if (effectType === 'binary') {
                    if (distance <= schoolDistance) {
                        if (!plantableArea.properties._schoolmean) {
                            plantableArea.properties._schoolmean = 0;
                        }
                        plantableArea.properties._schoolmean += schoolEffect + Math.random() * 5;
                    }
                } else if (effectType === 'gaussian') {
                    var weight = gaussianWeight(distance, schoolDistance, sigma, amplitude);
                    if (!plantableArea.properties._schoolmean) {
                        plantableArea.properties._schoolmean = 0;
                    }
                    plantableArea.properties._schoolmean += schoolEffect * weight;
                }
            });
        }
    });
    return geojsonData;
}


        function gaussianWeight(distance, effectDistance, sigma, amplitude) {
            var z = distance / (effectDistance * sigma);
            return amplitude * Math.exp(-0.5 * z * z);
        }
   
        // Function to apply tree effect
function applyTreeEffect(geojsonData, treeEffect, treeDistance) {
    var effectType = document.querySelector('input[name="effectType"]:checked').value;
    var sigma = parseFloat(document.getElementById('gaussianSigma').value);
    var amplitude = parseFloat(document.getElementById('gaussianAmplitude').value);

    var plantableIndex = new RBush();
    geojsonData.features.forEach(function(feature) {
        if (feature.properties.canopy_type === 'plantable') {
            var bbox = turf.bbox(feature);
            plantableIndex.insert({
                minX: bbox[0],
                minY: bbox[1],
                maxX: bbox[2],
                maxY: bbox[3],
                feature: feature
            });
        }
    });

    var treeLayer = map.getSource('treesLayer')._data;

    treeLayer.features.forEach(function(treeFeature) {
        const treePoint = treeFeature.geometry.coordinates;
        const treePointGeoJSON = turf.point(treePoint);
        const boundingBox = turf.bbox(turf.circle(treePointGeoJSON, treeDistance, { units: 'meters' }));

        var plantablesInRange = plantableIndex.search({
            minX: boundingBox[0],
            minY: boundingBox[1],
            maxX: boundingBox[2],
            maxY: boundingBox[3]
        });

        plantablesInRange.forEach(function(plantable) {
            var feature = plantable.feature;
            var areaCentroid = turf.centroid(feature).geometry.coordinates;

            var distance = turf.distance(treePointGeoJSON, turf.point(areaCentroid), { units: 'meters' });

            if (effectType === 'binary') {
                if (distance <= treeDistance) {
                    if (!feature.properties._treemean) {
                        feature.properties._treemean = 0;
                    }
                    feature.properties._treemean -= treeEffect;
                }
            } else if (effectType === 'gaussian') {
                var weight = gaussianWeight(distance, treeDistance, sigma, amplitude);
                if (!feature.properties._treemean) {
                    feature.properties._treemean = 0;
                }
                feature.properties._treemean -= treeEffect * weight;
            }
        });
    });

    return geojsonData;
}
var treeCircles = [];

function toggleTreeData() {
    var treeDataVisible = document.getElementById('treeToggleView').checked;
    var showTreeRadius = document.getElementById('treeRadiusToggle').checked;

    if (treeDataVisible) {
        $.getJSON(`./borosTrees/boro_cd_${document.getElementById('boroSelect').value}.geojson`, function(data) {
            map.getSource('treesLayer').setData(data);

            const treeFeatures = [];
            const circleFeatures = [];
            treeCircles = [];

            data.features.forEach(feature => {
                const [lng, lat] = [feature.properties.longitude, feature.properties.Latitude];
                console.log('Adding tree:', lng, lat);

                // Add tree point feature
                treeFeatures.push({
                    type: 'Feature',
                    geometry: {
                        type: 'Point',
                        coordinates: [lng, lat]
                    },
                    properties: {}
                });

                // Add tree cooling effect circle feature
                if (showTreeRadius) {
                    const coolingDistance = parseInt(document.getElementById('treeCoolingDistance').value);
                    const effectCircle = turf.circle([lng, lat], coolingDistance, { units: 'meters' });
                    const circleId = 'treesCircle_' + lng + '_' + lat;

                    treeCircles.push({
                        id: circleId,
                        coordinates: [lng, lat]
                    });

                    circleFeatures.push({
                        type: 'Feature',
                        geometry: effectCircle.geometry,
                        properties: {}
                    });
                }
            });

            // Update treesLayer with all tree points
            map.getSource('treesLayer').setData({
                type: 'FeatureCollection',
                features: treeFeatures
            });

            // Update or add circlesLayer with all cooling effect circles
            if (showTreeRadius) {
                if (map.getSource('circlesLayer')) {
                    map.getSource('circlesLayer').setData({
                        type: 'FeatureCollection',
                        features: circleFeatures
                    });
                } else {
                    map.addSource('circlesLayer', {
                        type: 'geojson',
                        data: {
                            type: 'FeatureCollection',
                            features: circleFeatures
                        }
                    });

                    map.addLayer({
                        id: 'circlesLayer',
                        type: 'line',
                        source: 'circlesLayer',
                        paint: {
                            'line-color': '#008000', // Green color
                            'line-width': 2
                        }
                    });
                }
            } else if (map.getSource('circlesLayer')) {
                // Hide circles layer if not showing tree radius
                map.getSource('circlesLayer').setData({
                    type: 'FeatureCollection',
                    features: []
                });
            }

            updatePlantableAreaColors();
        });
    } else {
        if (map.getSource('treesLayer')) {
            map.getSource('treesLayer').setData({
                type: 'FeatureCollection',
                features: []
            });
        }
        if (map.getSource('circlesLayer')) {
            map.getSource('circlesLayer').setData({
                type: 'FeatureCollection',
                features: []
            });
        }

        updatePlantableAreaColors();
    }
}


// Function to toggle tree radius visibility
function toggleTreeRadius() {
    var showTreeRadius = document.getElementById('treeRadiusToggle').checked;
    if (showTreeRadius) {
        toggleTreeData();
    } else {
        if (map.getSource('circlesLayer')) {
            map.getSource('circlesLayer').setData({
                type: 'FeatureCollection',
                features: []
            });
        }
    }
}



document.getElementById('treeToggleView').addEventListener('change', toggleTreeSettings);
document.getElementById('treeRadiusToggle').addEventListener('change', toggleTreeRadius);


function toggleTreeSettings() {
    toggleTreeData();
    var treeSettings = document.getElementById('treeSettings');
    var treeToggle = document.getElementById('treeToggleView').checked;
    treeSettings.style.display = treeToggle ? "block" : "none";
}


function toggleFacilityData() {
    var facilityDataVisible = document.getElementById('facilityToggleView').checked;
    var showFacilityRadius = document.getElementById('facilityRadiusToggle').checked;
    if (facilityDataVisible) {
        $.getJSON(`./borosFacilities/boro_cd_${document.getElementById('boroSelect').value}.geojson`, function(data) {
            map.getSource('facilityLayer').setData(data);

            const facilityFeatures = [];
            const facilityCircleFeatures = [];
            facilityCircles = [];

            data.features.forEach(feature => {
                // const [lng, lat] = feature.geometry.coordinates;
                // lng is feature.properties.LONGITUDE and lat is feature.properties.LATITUDE
                const [lng, lat] = [feature.properties.LONGITUDE, feature.properties.LATITUDE];
                facilityFeatures.push({
                    type: 'Feature',
                    geometry: {
                        type: 'Point',
                        coordinates: [lng, lat]
                    },
                    properties: {}
                });

                if (showFacilityRadius) {
                    const heatingDistance = parseInt(document.getElementById('facilityHeatingDistance').value);
                    const effectCircle = turf.circle([lng, lat], heatingDistance, { units: 'meters' });
                    const circleId = 'facilityCircle_' + lng + '_' + lat;

                    facilityCircles.push({
                        id: circleId,
                        coordinates: [lng, lat]
                    });

                    facilityCircleFeatures.push({
                        type: 'Feature',
                        geometry: effectCircle.geometry,
                        properties: {}
                    });
                }
            });

            map.getSource('facilityLayer').setData({
                type: 'FeatureCollection',
                features: facilityFeatures
            });

            if (showFacilityRadius) {
                if (map.getSource('facilityCirclesLayer')) {
                    map.getSource('facilityCirclesLayer').setData({
                        type: 'FeatureCollection',
                        features: facilityCircleFeatures
                    });
                } else {
                    map.addSource('facilityCirclesLayer', {
                        type: 'geojson',
                        data: {
                            type: 'FeatureCollection',
                            features: facilityCircleFeatures
                        }
                    });

                    map.addLayer({
                        id: 'facilityCirclesLayer',
                        type: 'line',
                        source: 'facilityCirclesLayer',
                        paint: {
                            'line-color': '#0000FF', // Blue color
                            'line-width': 2
                        }
                    });
                }
            } else if (map.getSource('facilityCirclesLayer')) {
                map.getSource('facilityCirclesLayer').setData({
                    type: 'FeatureCollection',
                    features: []
                });
            }

            updatePlantableAreaColors();
        });
    } else {
        if (map.getSource('facilityLayer')) {
            map.getSource('facilityLayer').setData({
                type: 'FeatureCollection',
                features: []
            });
        }
        if (map.getSource('facilityCirclesLayer')) {
            map.getSource('facilityCirclesLayer').setData({
                type: 'FeatureCollection',
                features: []
            });
        }

        updatePlantableAreaColors();
    }
}

function toggleFacilityRadius() {
    var showFacilityRadius = document.getElementById('facilityRadiusToggle').checked;
    if (showFacilityRadius) {
        toggleFacilityData();
    } else {
        if (map.getSource('facilityCirclesLayer')) {
            map.getSource('facilityCirclesLayer').setData({
                type: 'FeatureCollection',
                features: []
            });
        }
    }
}

function toggleFacilitySettings() {
    toggleFacilityData();
    var facilitySettings = document.getElementById('facilitySettings');
    var facilityToggle = document.getElementById('facilityToggleView').checked;
    facilitySettings.style.display = facilityToggle ? "block" : "none";
}
// Function to update the radius of existing facility circles
function updateFacilityHeatingDistance() {
    const heatingDistance = parseInt(document.getElementById('facilityHeatingDistance').value);

    const updatedCircleFeatures = [];

    facilityCircles.forEach(circle => {
        const coordinates = circle.coordinates;
        const effectCircle = turf.circle(coordinates, heatingDistance, { units: 'meters' });

        updatedCircleFeatures.push({
            type: 'Feature',
            geometry: effectCircle.geometry,
            properties: {}
        });
    });

    if (map.getSource('facilityCirclesLayer')) {
        map.getSource('facilityCirclesLayer').setData({
            type: 'FeatureCollection',
            features: updatedCircleFeatures
        });
    }
    
    updatePlantableAreaColors();
}

// Event listener for the heating distance change
document.getElementById('facilityHeatingDistance').addEventListener('change', function() {
    updateFacilityHeatingDistance();
    updatePlantableAreaColors();
});



        function toggleGaussianSettings() {
            var effectType = document.querySelector('input[name="effectType"]:checked').value;
            var gaussianSettings = document.getElementById('gaussianSettings');
            gaussianSettings.style.display = effectType === 'gaussian' ? 'block' : 'none';
        }

        document.getElementById('heatIndexScale').addEventListener('input', updatePlantableAreaColors);
        document.querySelectorAll('input[name="effectType"]').forEach(function(radio) {
            radio.addEventListener('change', updatePlantableAreaColors);
        });

        document.getElementById('gaussianSigma').addEventListener('change', updatePlantableAreaColors);
        document.getElementById('gaussianAmplitude').addEventListener('change', updatePlantableAreaColors);

        document.getElementById('schoolHeatingEffect').addEventListener('change', updatePlantableAreaColors);
        document.getElementById('schoolHeatingDistance').addEventListener('change', function() {
            updatePlantableAreaColors();
        });

        document.getElementById('treeCoolingDistance').addEventListener('change', function() {
    updateTreeCoolingDistance();
    updatePlantableAreaColors();
});

document.getElementById('treeCoolingEffect').addEventListener('change', updatePlantableAreaColors);

document.getElementById('treeToggleView').addEventListener('change', updatePlantableAreaColors);


        document.getElementById('heatIndexScale').addEventListener('input', updatePlantableAreaColors);
        document.getElementById('schoolToggleView').addEventListener('change', updatePlantableAreaColors);

        document.getElementById('plantingViewToggle').addEventListener('change', function() {
            updateTreePlanting();
            if (!document.getElementById('plantingViewToggle').checked) {
                updatePlantableAreaColors();
            }
        });

        document.getElementById('facilityHeatingEffect').addEventListener('change', updatePlantableAreaColors);
        document.getElementById('facilityHeatingDistance').addEventListener('change', function() {
            updatePlantableAreaColors();
        });
        document.getElementById('facilityToggleView').addEventListener('change', updatePlantableAreaColors);

        document.getElementById('streetEffect').addEventListener('change', updatePlantableAreaColors);
        document.getElementById('streetBufferDistance').addEventListener('change', function() {
            updatePlantableAreaColors();
        });
        document.getElementById('streetWeightField').addEventListener('change', updatePlantableAreaColors);

        var boroughPattern = /boro_cd_(\d+)\.geojson/;


        const boroughFiles = [
    'boro_cd_104.geojson',
    'boro_cd_105.geojson',
    'boro_cd_106.geojson',
    'boro_cd_107.geojson',
    'boro_cd_109.geojson',
    'boro_cd_110.geojson',
    'boro_cd_111.geojson',
    'boro_cd_112.geojson',
    'boro_cd_164.geojson',
    'boro_cd_201.geojson',
    'boro_cd_202.geojson',
    'boro_cd_203.geojson',
    'boro_cd_204.geojson',
    'boro_cd_205.geojson',
    'boro_cd_206.geojson',
    'boro_cd_207.geojson',
    'boro_cd_226.geojson',
    'boro_cd_228.geojson',
    'boro_cd_301.geojson',
    'boro_cd_302.geojson',
    'boro_cd_303.geojson',
    'boro_cd_304.geojson',
    'boro_cd_306.geojson',
    'boro_cd_308.geojson',
    'boro_cd_310.geojson',
    'boro_cd_314.geojson',
    'boro_cd_402.geojson',
    'boro_cd_403.geojson',
    'boro_cd_404.geojson',
    'boro_cd_409.geojson',
    'boro_cd_480.geojson',
    'boro_cd_481.geojson',
    'boro_cd_482.geojson',
    'boro_cd_483.geojson',
    'boro_cd_484.geojson',
    'boro_cd_595.geojson',
    'boro_cd_NULL.geojson'
];

function loadBoroughOptions() {
    boroughFiles.forEach(filename => {
        const match = filename.match(boroughPattern);
        if (match) {
            const boroughCode = match[1];
            const option = $("<option>").val(boroughCode).text("Borough " + boroughCode);
            $("#boroSelect").append(option);
        }
    });

    // Trigger the initial borough switch after loading options
    switchBorough();
}


        async function loadGeoJson(url) {
    return new Promise((resolve, reject) => {
        $.getJSON(url, function(data) {
            resolve(data);
        }).fail(function() {
            reject(new Error('Failed to load GeoJSON data'));
        });
    });
}

async function switchBorough() {
    var selectedBorough = document.getElementById('boroSelect').value;
    var currentBorough = document.getElementById('boroSelect').getAttribute('data-current');

    if (selectedBorough === currentBorough) {
        return;
    }

    clearPlantedTrees();
    clearMapLayers();

    document.getElementById('boroSelect').setAttribute('data-current', selectedBorough);

    try {
        const [boroughData, schoolData, facilityData, streetData] = await Promise.all([
            loadGeoJson(`./boros/boro_cd_${selectedBorough}.geojson`),
            loadGeoJson(`./borosSchools/boro_cd_${selectedBorough}.geojson`),
            loadGeoJson(`./borosFacilities/boro_cd_${selectedBorough}.geojson`),
            loadGeoJson(`./borosStreets/boro_cd_${selectedBorough}.geojson`) // Load street data
        ]);

        originalGeoJsonData = boroughData;
        calculateMinMaxMean(originalGeoJsonData);
        displayGeoJson(originalGeoJsonData);
        updatePlantableAreaColors();
        zoomToBorough(boroughData);

        // Handle school data
        if (map.getSource('schoolLayer')) {
            map.setLayoutProperty('schoolLayer', 'visibility', 'none');
            map.getSource('schoolLayer').setData(schoolData);
        }

        if (document.getElementById('schoolToggleView').checked) {
            createSchoolCircles(schoolData);
            toggleSchoolRadius();
        }

        // Handle tree data
        if (map.getSource('treesLayer') && document.getElementById('treeToggleView').checked) {
            const treeData = await loadGeoJson(`./borosTrees/boro_cd_${selectedBorough}.geojson`);
            map.getSource('treesLayer').setData(treeData);

            const treeFeatures = [];
            const circleFeatures = [];
            const showTreeRadius = document.getElementById('treeRadiusToggle').checked;
            treeCircles = [];

            treeData.features.forEach(feature => {
                const [lng, lat] = [feature.properties.longitude, feature.properties.Latitude];

                treeFeatures.push({
                    type: 'Feature',
                    geometry: {
                        type: 'Point',
                        coordinates: [lng, lat]
                    },
                    properties: {}
                });

                if (showTreeRadius) {
                    const coolingDistance = parseInt(document.getElementById('treeCoolingDistance').value);
                    const effectCircle = turf.circle([lng, lat], coolingDistance, { units: 'meters' });
                    const circleId = 'treesCircle_' + lng + '_' + lat;

                    treeCircles.push({
                        id: circleId,
                        coordinates: [lng, lat]
                    });

                    circleFeatures.push({
                        type: 'Feature',
                        geometry: effectCircle.geometry,
                        properties: {}
                    });
                }
            });

            map.getSource('treesLayer').setData({
                type: 'FeatureCollection',
                features: treeFeatures
            });

            if (showTreeRadius) {
                if (map.getSource('circlesLayer')) {
                    map.getSource('circlesLayer').setData({
                        type: 'FeatureCollection',
                        features: circleFeatures
                    });
                } else {
                    map.addSource('circlesLayer', {
                        type: 'geojson',
                        data: {
                            type: 'FeatureCollection',
                            features: circleFeatures
                        }
                    });

                    map.addLayer({
                        id: 'circlesLayer',
                        type: 'line',
                        source: 'circlesLayer',
                        paint: {
                            'line-color': '#008000',
                            'line-width': 2
                        }
                    });
                }
            } else if (map.getSource('circlesLayer')) {
                map.getSource('circlesLayer').setData({
                    type: 'FeatureCollection',
                    features: []
                });
            }
        }

        // Handle facility data
        if (map.getSource('facilityLayer') && document.getElementById('facilityToggleView').checked) {
            map.getSource('facilityLayer').setData(facilityData);

            const facilityFeatures = [];
            const circleFeatures = [];
            const showFacilityRadius = document.getElementById('facilityRadiusToggle').checked;
            facilityCircles = [];

            facilityData.features.forEach(feature => {
                const [lng, lat] = [feature.properties.LONGITUDE, feature.properties.LATITUDE];

                facilityFeatures.push({
                    type: 'Feature',
                    geometry: {
                        type: 'Point',
                        coordinates: [lng, lat]
                    },
                    properties: {}
                });

                if (showFacilityRadius) {
                    const heatingDistance = parseInt(document.getElementById('facilityHeatingDistance').value);
                    const effectCircle = turf.circle([lng, lat], heatingDistance, { units: 'meters' });

                    facilityCircles.push({
                        coordinates: [lng, lat]
                    });

                    circleFeatures.push({
                        type: 'Feature',
                        geometry: effectCircle.geometry,
                        properties: {}
                    });
                }
            });

            map.getSource('facilityLayer').setData({
                type: 'FeatureCollection',
                features: facilityFeatures
            });

            if (showFacilityRadius) {
                map.getSource('facilityCirclesLayer').setData({
                    type: 'FeatureCollection',
                    features: circleFeatures
                });
            } else {
                map.getSource('facilityCirclesLayer').setData({
                    type: 'FeatureCollection',
                    features: []
                });
            }
        } else if (map.getSource('facilityLayer')) {
            map.getSource('facilityLayer').setData({
                type: 'FeatureCollection',
                features: []
            });
            map.getSource('facilityCirclesLayer').setData({
                type: 'FeatureCollection',
                features: []
            });
        }

        // Handle street data
        if (map.getSource('streetsLayer')) {
            map.removeLayer('streetsLayer');
            map.removeSource('streetsLayer');
        }

        if (map.getSource('streetBuffersLayer')) {
            map.removeLayer('streetBuffersLayer');
            map.removeSource('streetBuffersLayer');
        }

        if (document.getElementById('streetToggleView').checked) {
            loadStreets().then(() => {
                const showStreetBuffer = document.getElementById('streetBufferToggle').checked;
                toggleStreetBuffer(showStreetBuffer); // Ensure buffer visibility matches toggle state
            });
        }


    } catch (error) {
        console.error('Error loading data:', error);
    }
}





        function zoomToBorough(geojsonData) {
        var bounds = turf.bbox(geojsonData);
        map.fitBounds([[bounds[0], bounds[1]], [bounds[2], bounds[3]]]); // Correct order: [latitude, longitude]
    }

// Define an array to store school circles and their IDs
var schoolCircles = [];

function createSchoolCircles(data) {
    const heatingDistance = parseInt(document.getElementById('schoolHeatingDistance').value);
    const showSchoolRadius = document.getElementById('schoolRadiusToggle').checked;

    data.features.forEach(feature => {
        const coordinates = feature.geometry.coordinates;
        console.log('Creating circle for school with coordinates:', coordinates);
        const effectCircle = turf.circle(coordinates, heatingDistance, { units: 'meters' });
        const circleId = coordinates.join('_');

        if (map.getSource(circleId)) {
            map.getSource(circleId).setData(effectCircle);
        } else {
            schoolCircles.push({
                id: circleId,
                data: effectCircle
            });

            map.addSource(circleId, {
                type: 'geojson',
                data: effectCircle
            });

            map.addLayer({
                id: circleId,
                type: 'line',
                source: circleId,
                paint: {
                    'line-color': 'red',
                    'line-width': 2,
                    'line-opacity': 1
                },
                layout: {
                    'visibility': showSchoolRadius ? 'visible' : 'none'
                }
            });

            const pointId = 'schoolPoint_' + circleId;
            if (map.getSource(pointId)) {
                map.getSource(pointId).setData({
                    type: 'Feature',
                    geometry: {
                        type: 'Point',
                        coordinates: coordinates
                    }
                });
            } else {
                map.addSource(pointId, {
                    type: 'geojson',
                    data: {
                        type: 'Feature',
                        geometry: {
                            type: 'Point',
                            coordinates: coordinates
                        }
                    }
                });

                map.addLayer({
                    id: pointId,
                    type: 'circle',
                    source: pointId,
                    paint: {
                        'circle-radius': 5,
                        'circle-color': 'red',
                        'circle-opacity': 1
                    }
                });
            }
        }
    });
}
function updateTreeCoolingDistance() {
    var coolingDistance = parseInt(document.getElementById('treeCoolingDistance').value);
    var showTreeRadius = document.getElementById('treeRadiusToggle').checked;

    // Remove existing circles
    if (map.getSource('circlesLayer')) {
        map.removeLayer('circlesLayer');
        map.removeSource('circlesLayer');
    }

    const circleFeatures = [];

    treeCircles.forEach(circle => {
        var coordinates = circle.coordinates;
        var effectCircle = turf.circle(coordinates, coolingDistance, { units: 'meters' });

        circleFeatures.push({
            type: 'Feature',
            geometry: effectCircle.geometry,
            properties: {}
        });
    });

    if (showTreeRadius) {
        map.addSource('circlesLayer', {
            type: 'geojson',
            data: {
                type: 'FeatureCollection',
                features: circleFeatures
            }
        });

        map.addLayer({
            id: 'circlesLayer',
            type: 'line',
            source: 'circlesLayer',
            paint: {
                'line-color': '#008000', // Green color for outline
                'line-width': 2
            },
            layout: {
                'visibility': showTreeRadius ? 'visible' : 'none'
            }
        });
    }

    updatePlantableAreaColors();
}




// Function to update the school heating distance
function updateSchoolHeatingDistance() {
    const heatingDistance = parseInt(document.getElementById('schoolHeatingDistance').value);

    schoolCircles.forEach(circle => {
        if (circle.id.startsWith('schoolPoint_')) return; // Skip school points
        const coordinates = circle.id.split('_').map(coord => parseFloat(coord));
        console.log('Updating circle ID:', circle.id, 'with coordinates:', coordinates);

        // Ensure the coordinates are in the correct format
        if (Array.isArray(coordinates) && coordinates.length === 2 && typeof coordinates[0] === 'number' && typeof coordinates[1] === 'number') {
            const effectCircle = turf.circle(coordinates, heatingDistance, { units: 'meters' });
            map.getSource(circle.id).setData(effectCircle);
        } else {
            console.error('Invalid coordinates for turf.circle:', coordinates);
        }
    });

    updatePlantableAreaColors();
}

function toggleSchoolData() {
    var schoolDataVisible = document.getElementById('schoolToggleView').checked;
    var selectedBorough = document.getElementById('boroSelect').value;

    if (schoolDataVisible) {
        // Fetch and add the school data for the selected borough
        map.setLayoutProperty('schoolLayer', 'visibility', 'visible');
        schoolCircles.forEach(circle => {
            map.setLayoutProperty(circle.id, 'visibility', 'visible');
            const pointId = 'schoolPoint_' + circle.id;
            map.setLayoutProperty(pointId, 'visibility', 'visible');
        });
        $.getJSON('borosSchools/boro_cd_' + selectedBorough + '.geojson', function(data) {
            createSchoolCircles(data);
            updatePlantableAreaColors();
        });
    } else {
        map.setLayoutProperty('schoolLayer', 'visibility', 'none');
        schoolCircles.forEach(circle => {
            map.setLayoutProperty(circle.id, 'visibility', 'none');
            const pointId = 'schoolPoint_' + circle.id;
            map.setLayoutProperty(pointId, 'visibility', 'none');
        });
    }
}


// Function to toggle school radius visibility
function toggleSchoolRadius() {
    const showSchoolRadius = document.getElementById('schoolRadiusToggle').checked;
    console.log('Toggling school radius visibility:', showSchoolRadius);

    schoolCircles.forEach(circle => {
        console.log('Setting visibility for circle ID:', circle.id);
        map.setLayoutProperty(circle.id, 'visibility', showSchoolRadius ? 'visible' : 'none');
    });
}

// Function to toggle school settings
function toggleSchoolSettings() {
    toggleSchoolData();
    const schoolSettings = document.getElementById('schoolSettings');
    const schoolToggle = document.getElementById('schoolToggleView').checked;
    schoolSettings.style.display = schoolToggle ? 'block' : 'none';
}

// Add event listeners
document.getElementById('schoolHeatingEffect').addEventListener('change', updatePlantableAreaColors);
document.getElementById('schoolHeatingDistance').addEventListener('change', function() {
    updateSchoolHeatingDistance();
    updatePlantableAreaColors();
});
document.getElementById('schoolToggleView').addEventListener('change', toggleSchoolSettings);
document.getElementById('schoolRadiusToggle').addEventListener('change', toggleSchoolRadius);

// Initialize borough options and event listener for borough change
loadBoroughOptions();
document.getElementById('boroSelect').addEventListener('change', switchBorough);

// // Ensure school data is shown when switching boroughs if school data toggle is enabled
// function switchBorough() {
//     var selectedBorough = document.getElementById('boroSelect').value;
//     var currentBorough = document.getElementById('boroSelect').getAttribute('data-current');

//     if (selectedBorough === currentBorough) {
//         return;
//     }

//     clearPlantedTrees();
//     clearMapLayers();

//     document.getElementById('boroSelect').setAttribute('data-current', selectedBorough);

//     $.getJSON('./boros/boro_cd_' + selectedBorough + '.geojson', function(data) {
//         originalGeoJsonData = data;
//         calculateMinMaxMean(originalGeoJsonData);
//         displayGeoJson(originalGeoJsonData);
//         updatePlantableAreaColors();
//         zoomToBorough(data);
//     });

//     $.getJSON('./borosSchools/boro_cd_' + selectedBorough + '.geojson', function(data) {
//         map.setLayoutProperty('schoolLayer', 'visibility', 'none');
//         map.getSource('schoolLayer').setData(data);
//         if (document.getElementById('schoolToggleView').checked) {
//             createSchoolCircles(data);
//         }
//     });
// }


function toggleStreetData() {
    const streetDataVisible = document.getElementById('streetToggleView').checked;
    const showStreetBuffer = document.getElementById('streetBufferToggle').checked;

    if (streetDataVisible) {
        if (map.getSource('streetsLayer')) {
            map.setLayoutProperty('streetsLayer', 'visibility', 'visible');
            toggleStreetBuffer(showStreetBuffer); // Handle buffer visibility
        } else {
            loadStreets().then(() => {
                const showStreetBuffer = document.getElementById('streetBufferToggle').checked;
                toggleStreetBuffer(showStreetBuffer); // Ensure buffer visibility matches toggle state
            });
        }
    } else {
        if (map.getSource('streetsLayer')) {
            map.setLayoutProperty('streetsLayer', 'visibility', 'none');
        }
        if (map.getSource('streetBuffersLayer')) {
            map.setLayoutProperty('streetBuffersLayer', 'visibility', 'none');
        }
    }
}



function loadStreets() {
    var selectedBorough = document.getElementById('boroSelect').value;

    return new Promise((resolve, reject) => {
        $.getJSON(`./borosStreets/boro_cd_${selectedBorough}.geojson`, function(data) {
            if (!map.getSource('streetsLayer')) {
                map.addSource('streetsLayer', {
                    type: 'geojson',
                    data: data
                });

                map.addLayer({
                    id: 'streetsLayer',
                    type: 'line',
                    source: 'streetsLayer',
                    paint: {
                        'line-color': 'gray',
                        'line-width': 2,
                        'line-opacity': 0.7
                    }
                });
            } else {
                map.getSource('streetsLayer').setData(data);
            }

            updateStreetBuffers(data); // Pass the data to the buffer update function
            resolve();
        }).fail(reject);
    });
}



function updateStreetBuffers(streetData) {
    if (!streetData) {
        streetData = map.getSource('streetsLayer')._data;
    }
    
    const bufferDistance = parseInt(document.getElementById('streetBufferDistance').value);
    const streetBuffers = [];

    streetData.features.forEach(feature => {
        const buffer = turf.buffer(feature, bufferDistance, { units: 'meters' });
        streetBuffers.push(buffer);
    });

    if (map.getSource('streetBuffersLayer')) {
        map.getSource('streetBuffersLayer').setData({
            type: 'FeatureCollection',
            features: streetBuffers
        });
        map.setLayoutProperty('streetBuffersLayer', 'visibility', 'visible');
    } else {
        map.addSource('streetBuffersLayer', {
            type: 'geojson',
            data: {
                type: 'FeatureCollection',
                features: streetBuffers
            }
        });

        map.addLayer({
            id: 'streetBuffersLayer',
            type: 'fill',
            source: 'streetBuffersLayer',
            paint: {
                'fill-color': 'blue',
                'fill-opacity': 0.2
            }
        });
    }
}





function toggleStreetBuffer(showBuffer) {
    map.setLayoutProperty('streetBuffersLayer', 'visibility', showBuffer ? 'visible' : 'none');
}

function applyStreetEffect(geojsonData, streetEffect, streetBufferDistance, streetWeightField) {
    if (!document.getElementById('streetToggleView').checked) {
        return geojsonData;
    }

    var plantableIndex = new RBush();
    geojsonData.features.forEach(function(feature) {
        if (feature.properties.canopy_type === 'plantable') {
            var bbox = turf.bbox(feature);
            plantableIndex.insert({
                minX: bbox[0],
                minY: bbox[1],
                maxX: bbox[2],
                maxY: bbox[3],
                feature: feature
            });
        }
    });

    var streetData = map.getSource('streetsLayer')._data;
    streetData.features.forEach(function(streetFeature) {
        var buffer = turf.buffer(streetFeature, streetBufferDistance, { units: 'meters' });
        var boundingBox = turf.bbox(buffer);

        var plantablesInRange = plantableIndex.search({
            minX: boundingBox[0],
            minY: boundingBox[1],
            maxX: boundingBox[2],
            maxY: boundingBox[3]
        });

        plantablesInRange.forEach(function(plantable) {
            var feature = plantable.feature;
            var intersection = turf.intersect(feature, buffer);

            if (intersection) {
                var streetWeight = streetFeature.properties[streetWeightField];
                streetWeight = isNaN(streetWeight) ? 0 : streetWeight;

                var effect = streetEffect * streetWeight;

                if (!feature.properties._streetmean) {
                    feature.properties._streetmean = 0;
                }
                feature.properties._streetmean += effect;
            }
        });
    });

    return geojsonData;
}


// Event listeners for street settings
document.getElementById('streetBufferDistance').addEventListener('change', function() {
    if (document.getElementById('streetToggleView').checked) {
        loadStreets();
    }
});
document.getElementById('streetEffect').addEventListener('change', updatePlantableAreaColors);
document.getElementById('streetWeightField').addEventListener('change', updatePlantableAreaColors);
document.getElementById('streetToggleView').addEventListener('change', toggleStreetSettings);
document.getElementById('streetBufferToggle').addEventListener('change', function() {
    toggleStreetBuffer(document.getElementById('streetBufferToggle').checked);
});

function toggleStreetSettings() {
    toggleStreetData();
    var streetSettings = document.getElementById('streetSettings');
    var streetToggle = document.getElementById('streetToggleView').checked;
    streetSettings.style.display = streetToggle ? "block" : "none";
}



        loadBoroughOptions();

        document.getElementById('boroSelect').addEventListener('change', switchBorough);
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tree Planting Map</title>
    <link href='https://api.mapbox.com/mapbox-gl-js/v2.10.0/mapbox-gl.css' rel='stylesheet' />
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.1/css/all.css">
    <style>
        body {
            display: flex;
            font-family: 'Arial', sans-serif;
            margin:0px;
        }
        #sidebar {
            width: 300px;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            background-color: #f4f4f4;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        }
        #map {
            height: 100vh;
            flex-grow: 1;
        }
        .input-group {
            margin: 15px 0;
            display: flex;
            flex-direction: column;
        }
        .input-group label {
            margin-bottom: 5px;
            font-weight: bold;
        }
        .input-group input {
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 5px;
        }
        button {
            margin-top:10px;
            padding: 10px 20px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        button:hover {
            background-color: #45a049;
        }

        /* Style for the custom checkbox */
        .custom-checkbox {
            display: inline-block;
            position: relative;
            padding-left: 25px;
            cursor: pointer;
            font-size: 16px;
            line-height: 20px;
            user-select: none;
        }

        /* Hide the default checkbox */
        .custom-checkbox input {
            position: absolute;
            opacity: 0;
            cursor: pointer;
            height: 0;
            width: 0;
        }

        /* Create a custom checkbox */
        .checkmark {
            position: absolute;
            top: 0;
            left: 0;
            height: 20px;
            width: 20px;
            background-color: #eee;
            border-radius: 4px;
        }

        /* When the checkbox is checked, add a blue background */
        .custom-checkbox input:checked ~ .checkmark {
            background-color: #2196F3;
        }

        /* Create the checkmark/indicator (hidden when not checked) */
        .checkmark:after {
            content: "\f00c"; /* Correct code for FontAwesome checkmark */
            font-family: "Font Awesome 5 Free";
            font-weight: 900; /* FontAwesome 5 requires explicit font-weight for solid icons */
            position: absolute;
            display: none;
            color: white;
            top: -2px;
            left: 5px;
            font-size: 14px;
        }

        /* Show the checkmark when checked */
        .custom-checkbox input:checked ~ .checkmark:after {
            display: block;
        }

        /* Style the checkmark/indicator */
        .custom-checkbox .checkmark:after {
            left: 5px;
            top: 0px;
        }

        .district-label-tooltip {
            background-color: transparent;
            border: none;
            box-shadow: none;
            font-size: 14px;
            color: black;
            text-align: center;
            padding: 0;
            pointer-events: none;
            z-index: 1000000;
        }

        .district-label {
            font-weight: normal;
            z-index: 1000000;
        }

        #treePopup {
    position: absolute;
    bottom: 10px;
    left: 50%;
    transform: translateX(-50%);
    background-color: white;
    border: 1px solid #ccc;
    border-radius: 20px;
    box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
    padding: 10px;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 10px;
    z-index: 10000;
}

#treePopupContent {
    display: flex;
    align-items: center;
    gap: 10px;
}

#homeButton {
    cursor: pointer;
    font-size: 20px;
    user-select: none;
}

#treeNumberInput {
    width: 50px;
    padding: 5px;
    text-align: center;
    border-radius: 5px;
    border: 1px solid #ccc;
}


#leftArrow, #rightArrow {
    cursor: pointer;
    font-size: 20px;
    user-select: none;
}

#treeScoreBar {
    display: flex;
    gap: 2px;
    /* width: 100%; */
    margin-top: 10px;
    height: 20px;
    align-items: center;
    width: 300px;
}

#treeScoreBar div {
    height: 100%;
    text-align: center;
    font-size: 12px;
    color: white;
}

#treeTitle {
    text-align: center;
    width: 50px;
    font-weight: bold;
}

#boroSelect {
    position: relative;
    display: inline-block;
    border: 1px solid #ccc;
    border-radius: 5px;
}
#boroSelect:before {
    content: '';
    height: (36 - 5)px;
    position: absolute;
    right: 7px;
    top: 3px;
    width: 22px;

    /* //background: -webkit-linear-gradient(#fff, #f0f0f0);
    //background: -moz-linear-gradient(#fff, #f0f0f0);
    //background: linear-gradient(#f5f5f5, #e0e0e0); */
    background: #fff; 

    border-top-right-radius: 3px;
    border-bottom-right-radius: 3px;
    pointer-events: none;
    display: block;
  }
  #boroSelect:after {
    content: " ";
    position: absolute;
    right: 15px;
    top: 46%;
    margin-top: -3px;
    z-index: 2;
    pointer-events: none;
    width: 0;
    height: 0;
    border-style: solid;
    border-width: 6.9px 4px 0 4px;
    border-color: #aaa transparent transparent transparent;
    pointer-events: none;
  }
  select {
    padding: 0 30px 0 10px;
    line-height: 36px;
    height: 36px;
    background: #fff;
  }

  .radio {
  display: block;
  cursor: pointer;
  -webkit-user-select: none;
     -moz-user-select: none;
      -ms-user-select: none;
          user-select: none;
  text-align: left;
}
.radio + .radio {
  margin-left: 12px;
}
.radio input {
  display: none;
}
.radio input + span {
  display: inline-block;
  position: relative;
  padding-left: 30px;
}
.radio input + span:before {
  content: '';
  display: block;
  position: absolute;
  top: 0px;
  left: 0px;
  border-radius: 50%;
  margin-right: 5px;
  width: 16px;
  height: 16px;
  border: 1px solid #ccc;
  background: #fff;
}
.radio input + span:after {
  content: '';
  display: block;
  width: 10px;
  height: 10px;
  /* background: #222; */
  background: #616161;
  position: absolute;
  border-radius: 50%;
  /* top: 3px;
  left: 3px; */
  top: 3.5px;
  left: 4px;
  opacity: 0;
  transform: scale(0, 0);
  transition: all 0.2s cubic-bezier(0.64, 0.57, 0.67, 1.53);
}
.radio input:checked + span:after {
  opacity: 1;
  transform: scale(1, 1);
}

/* Inline CSS for the stacked bar that will be used with html2canvas */
#pdfBarContainer {
    font-family: Arial, sans-serif;
    display: flex;
    flex-direction: row;
    width: 200px;
    height: 30px;
    border: 1px solid #aaa;
    border-radius: 6px;
    overflow: hidden;
    background: #f5f5f5;
    position: absolute;
    left: -9999px;
}

.barSegment {
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 8px;
    color: #000;
    font-weight: bold;
    white-space: nowrap;
    border-right: 1px solid #fff;
}

.barSegment:last-child {
    border-right: none;
}

    </style>
</head>
<body>

    <div id="sidebar">
        <h2 style="text-align: center;"><i class="fas fa-tree"></i> Treefolio Planting</h2>
        <form id="parametersForm">
            <div class="input-group">
                <label for="boroSelect">Select Borough:</label>
                <select id="boroSelect" data-current="">
                    <!-- Options will be dynamically added -->
                </select>
            </div>

            <div class="input-group">
                <label for="totalTrees">Total Trees:</label>
                <input type="number" id="totalTrees" name="totalTrees" value="100">
            </div>
            <div class="input-group">
                <label for="coolingEffect">Cooling Effect:</label>
                <input type="number" id="coolingEffect" name="coolingEffect" step="1" value="1">
            </div>
            <div class="input-group">
                <label for="coolingDistance">Cooling Distance (meters):</label>
                <input type="number" id="coolingDistance" name="coolingDistance" value="200">
            </div>
            <div style="display:flex; justify-content: space-between;">
            <button type="button" onclick="updateTreePlanting()">Plant Trees</button>
            <button id="exportButton" type="button" style="background-color:rgb(0, 123, 255); display: none;" onclick="exportToPDF()">Export</button>
            <button type="button" style="background-color:rgb(105, 2, 2)" onclick="clearPlantedTrees()">Clear</button>
            </div>
            <h4 id="results">...</h4>

            <div class="input-group" style="display: flex;
            flex-flow: row;">
                <label>Effect:</label>
                <label class="radio" style="margin-left: 32px;">
                    <input type="radio" name="effectType" value="binary" onchange="toggleGaussianSettings()" checked>
                    <span style="font-weight: 300;">Binary</span>
                </label>
                <label class="radio">
                    <input class="radio" type="radio" name="effectType" value="gaussian" onchange="toggleGaussianSettings()">
                    <span style="font-weight: 300;">Gaussian</span>
                </label>
            </div>
            <div id="gaussianSettings" style="display: none;">
                <div class="input-group">
                    <label for="gaussianSigma">Gaussian Sigma:</label>
                    <input type="number" id="gaussianSigma" name="gaussianSigma" step="0.1" value="1">
                </div>
                <div class="input-group">
                    <label for="gaussianAmplitude">Gaussian Amplitude:</label>
                    <input type="number" id="gaussianAmplitude" name="gaussianAmplitude" step="0.1" value="1">
                </div>
            </div>

            <label class="custom-checkbox">Heat Index
                <input type="checkbox" id="heatIndexToggle" name="heatIndexToggle" onchange="toggleHeatIndex()" checked>
                <span class="checkmark"></span>
            </label>
            <div id="heatIndexSettings" style="display: none;">
                <div class="input-group" style="display: none;">
                    <label for="heatIndexScale">Heat Index Scale:</label>
                    <input type="range" id="heatIndexScale" name="heatIndexScale" min="0.1" max="10" step="0.1" value="1">
                </div>
            </div>

            <!-- Tree Data Toggle and Settings -->
            <label class="custom-checkbox">Treefolio
                <input type="checkbox" id="treeToggleView" name="treeToggleView" onchange="toggleTreeSettings()">
                <span class="checkmark"></span>
            </label>
            <div id="treeSettings" style="display: none;">
                <label class="custom-checkbox">Show Tree Radius
                    <input type="checkbox" id="treeRadiusToggle" name="treeRadiusToggle" onchange="toggleTreeRadius()" checked>
                    <span class="checkmark"></span>
                </label>
                <div class="input-group">
                    <label for="treeCoolingEffect">Tree Cooling Effect:</label>
                    <input type="number" id="treeCoolingEffect" name="treeCoolingEffect" step="0.1" value="0.1">
                </div>
                <div class="input-group">
                    <label for="treeCoolingDistance">Tree Cooling Distance (meters):</label>
                    <input type="number" id="treeCoolingDistance" name="treeCoolingDistance" value="20">
                </div>
            </div>

            <!-- School Data Toggle and Settings -->
            <label class="custom-checkbox">Schools
                <input type="checkbox" id="schoolToggleView" name="schoolToggleView" onchange="toggleSchoolSettings()">
                <span class="checkmark"></span>
            </label>
            <div id="schoolSettings" style="display: none;">
                <label class="custom-checkbox">School Radius
                    <input type="checkbox" id="schoolRadiusToggle" name="schoolRadiusToggle" onchange="toggleSchoolRadius()" checked>
                    <span class="checkmark"></span>
                </label>
                <div class="input-group">
                    <label for="schoolHeatingEffect">School Heating Effect:</label>
                    <input type="number" id="schoolHeatingEffect" name="schoolHeatingEffect" step="0.1" value="0.1">
                </div>
                <div class="input-group">
                    <label for="schoolHeatingDistance">School Heating Distance (meters):</label>
                    <input type="number" id="schoolHeatingDistance" name="schoolHeatingDistance" value="200">
                </div>
            </div>

            <!-- Facility Data Toggle and Settings -->
            <label class="custom-checkbox">Facilities
                <input type="checkbox" id="facilityToggleView" name="facilityToggleView" onchange="toggleFacilitySettings()">
                <span class="checkmark"></span>
            </label>
            <div id="facilitySettings" style="display: none;">
                <label class="custom-checkbox">Facility Radius
                    <input type="checkbox" id="facilityRadiusToggle" name="facilityRadiusToggle" onchange="toggleFacilityRadius()" checked>
                    <span class="checkmark"></span>
                </label>
                <div class="input-group">
                    <label for="facilityHeatingEffect">Facility Heating Effect:</label>
                    <input type="number" id="facilityHeatingEffect" name="facilityHeatingEffect" step="0.1" value="0.1">
                </div>
                <div class="input-group">
                    <label for="facilityHeatingDistance">Facility Heating Distance (meters):</label>
                    <input type="number" id="facilityHeatingDistance" name="facilityHeatingDistance" value="60">
                </div>
            </div>

            <!-- Add the following in the sidebar section of the HTML -->
            <label class="custom-checkbox">Streets
                <input type="checkbox" id="streetToggleView" name="streetToggleView" onchange="toggleStreetSettings()">
                <span class="checkmark"></span>
            </label>
            <div id="streetSettings" style="display: none;">
                <label class="custom-checkbox">Street Buffer
                    <input type="checkbox" id="streetBufferToggle" name="streetBufferToggle" onchange="toggleStreetBuffer()" checked>
                    <span class="checkmark"></span>
                </label>
                <div class="input-group">
                    <label for="streetEffect">Street Effect:</label>
                    <input type="number" id="streetEffect" name="streetEffect" step="0.1" value="0.1">
                </div>
                <div class="input-group">
                    <label for="streetBufferDistance">Street Buffer Distance (meters):</label>
                    <input type="number" id="streetBufferDistance" name="streetBufferDistance" value="5">
                </div>
                <div class="input-group">
                    <label for="streetWeightField">Street Weight Field:</label>
                    <select id="streetWeightField" name="streetWeightField">
                        <option value="SHAPE_Leng">SHAPE_Leng</option>
                        <option value="BoroCode">BoroCode</option>
                        <option value="BoroName">BoroName</option>
                        <option value="BoroCD">BoroCD</option>
                        <option value="CounDist">CounDist</option>
                        <option value="AssemDist">AssemDist</option>
                        <option value="StSenDist">StSenDist</option>
                        <option value="CongDist">CongDist</option>
                        <option value="Rank">Rank</option>
                        <option value="PMP_ID">PMP_ID</option>
                        <option value="NTA2020">NTA2020</option>
                        <option value="Category">Category</option>
                        <option value="NTAName">NTAName</option>
                        <option value="FEMAFldz">FEMAFldz</option>
                        <option value="FEMAFldT">FEMAFldT</option>
                        <option value="HrcEvac">HrcEvac</option>
                    </select>
                </div>                
            </div>

            <label class="custom-checkbox">Planting View
                <input type="checkbox" id="plantingViewToggle" name="plantingViewToggle">
                <span class="checkmark"></span>
            </label>
        </form>
    </div>
    
    <div id="map">

        
        <div id="treePopup" style="display: none;">
            <div id="treePopupContent">
                <span id="leftArrow" onclick="navigateTree(-1)" style="display: none;">&#9664;</span>
                <span id="treeTitle"></span>
                <span id="rightArrow" onclick="navigateTree(1)" style="display: none;">&#9654;</span>
                <span id="homeButton" onclick="showTreeMenu()">&#8962;</span>
                <input type="number" id="treeNumberInput" style="display: none;" placeholder="Enter tree number" onchange="jumpToTree()">
                <div id="treeScoreBar"></div>
            </div>
        </div>
        

    </div>

    <script src='https://api.mapbox.com/mapbox-gl-js/v2.10.0/mapbox-gl.js'></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>
    <script src="shp.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/rbush@3.0.1/rbush.min.js"></script>


            <!-- Add these scripts for jsPDF and html2canvas -->
<!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script> -->
<script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/1.3.2/jspdf.min.js"></script> -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

    <script>

async function exportToPDF() {
    const selectedBorough = document.getElementById('boroSelect').value;
    const boroughNameAndDistrict = getBoroughNameAndDistrict(selectedBorough);

    // Flash boroughs and give them time to render
    flashOtherBoroughs(selectedBorough);

    // Take map screenshot now (with flashed boroughs)
    // const originalDpi = window.devicePixelRatio;
    // Object.defineProperty(window, 'devicePixelRatio', {
    //     get: function() { return 300 / 96; }
    // });

    let mapCanvas;
    let imgData;
    try {
        // mapCanvas = await html2canvas(map.getCanvasContainer(), { scale: 2 });
        // imgData = mapCanvas.toDataURL('image/png');
        // console.log(imgData);
        // console.log(mapCanvas);
        // console.log(mapCanvas.toDataURL('image/png'));
        html2canvas(map.getCanvasContainer(), { scale: 2 }).then(canvas => {
            imgData = map.getCanvas().toDataURL('image/png');
            console.log(imgData);
        });
    } catch (e) {
        console.error(e);
    }
    

    // Wait a bit to ensure flash is visible and map is updated
    await new Promise(res => setTimeout(res, 800));

    // Reset borough colors
    resetBoroughColors(selectedBorough);

    // Restore DPI
    // Object.defineProperty(window, 'devicePixelRatio', {
    //     get: function() { return originalDpi; }
    // });

    // const imgData = mapCanvas ? mapCanvas.toDataURL('image/png') : null;
// console.log(imgData);
    // await new Promise((res) => setTimeout(res, 500)); // Increase delay if necessary
    // const mapCanvas = await html2canvas(map.getCanvasContainer(), { scale: 2 });


    const pdf = new jspdf.jsPDF({
        orientation: 'portrait',
        unit: 'pt',
        format: 'letter'
    });

    // Constants for alignment
    const rightMargin = 450; // Adjust as per your page width
    const titleY = 60; // Y-coordinate of the title

    // Title (Treefolio Planting Priority)
    pdf.setFont("helvetica", "bold");
    pdf.setFontSize(16);
    pdf.text("Treefolio Planting Priority", 40, titleY); // Title text aligned left

    // Subtitle
    pdf.setFont("helvetica", "normal");
    pdf.setFontSize(12);
    pdf.text(`For ${boroughNameAndDistrict}`, 40, titleY + 20); // Subtitle slightly below title

    // Logo and link aligned to the same Y-coordinate
    pdf.setFont("helvetica", "normal");
    pdf.setFontSize(24);
    pdf.setTextColor(0, 128, 0);

    // TreeFolio logo (right-aligned at the same height as the title)
    pdf.text("T", rightMargin + 5 + 20, titleY);
    pdf.setFontSize(14);
    pdf.text("ree", rightMargin + 15 + 20, titleY);
    pdf.setFontSize(24);
    pdf.text("F", rightMargin + 40 + 20, titleY);
    pdf.setFontSize(14);
    pdf.text("olio", rightMargin + 50 + 20, titleY);

    // Link (below the logo)
    pdf.setFontSize(10);
    pdf.setTextColor(0, 0, 255);
    pdf.textWithLink('treefolio.org', rightMargin + 40, titleY + 15, { url: 'https://treefolio.org' });

    // Reset color for further text
    pdf.setTextColor(0, 0, 0);

    // Draw rounded rect and then map image inside it
    // Rounded rect: x=40,y=100,w=500,h=300, radius=10
    pdf.setDrawColor(0);
    pdf.setLineWidth(1);
    pdf.roundedRect(40,100,500,300,10,10,'S'); // Just stroke first
    
    // wait 1 second for the map image to be ready
    await new Promise(r=>setTimeout(r,1000));
    if (imgData) {
        console.log("Got image data");
        pdf.addImage(imgData, 'PNG', 45, 105, 490, 290);
    } else {
        console.log("No image data");
    }
    // Trees start after map
    let treeStartY = 420;
    pdf.setFontSize(14);
    pdf.setFont("helvetica", "bold");
    pdf.setTextColor(0, 0, 0);
    pdf.text("Recommended Trees:", 40, treeStartY);
    pdf.setFontSize(10);
    pdf.setFont("helvetica", "normal");
    treeStartY += 20;

    // Layout: Continuous rows with 3 columns
    const colWidth = 180;
    const rowHeight = 50; // Tighter vertical spacing
    const pageHeight = 820; // Max height for the page
    let yPos = treeStartY;

    // Cache bar chart images for faster rendering
    const cachedBarImages = await Promise.all(
    plantedTrees.map(treeData => {
        const barHTML = createBarHTML(treeData);

        const container = document.createElement('div');
        container.innerHTML = barHTML;
        document.body.appendChild(container);
        const barDiv = container.firstChild;

        // Adjust font size for text inside bars
        barDiv.style.fontSize = "24px";

        return html2canvas(barDiv, { scale: 2 })
        .then(canvas => {
            document.body.removeChild(container);
            return canvas.toDataURL('image/png');
        });
    })
    );

    for (let i = 0; i < plantedTrees.length; i++) {
    const col = i % 3; // 3 columns
    if (col === 0 && i > 0) {
        yPos += rowHeight; // Move to the next row after every 3 trees
    }

    // Check if we need a new page
    if (yPos + rowHeight > pageHeight) {
        pdf.addPage();
        pdf.setFontSize(14);
        pdf.setFont("helvetica", "bold");
        pdf.text("Recommended Trees (Cont.):", 40, 60);
        pdf.setFontSize(10);
        pdf.setFont("helvetica", "normal");
        yPos = 80; // Reset to top of new page
    }

    const xPos = 40 + col * colWidth;

    // Tree number
    pdf.setFont("helvetica", "bold");
    pdf.setFontSize(10);
    pdf.text(`Tree #${i + 1}`, xPos, yPos);

    // Link to map
    const treeFeature = map.getSource('treeMarkers')._data.features[i];
    const [lng, lat] = treeFeature.geometry.coordinates;
    const mapsUrl = `https://www.google.com/maps?q=${lat},${lng}`;
    pdf.setTextColor(0, 0, 225);
    pdf.textWithLink('View on Map', xPos + 100, yPos, { url: mapsUrl });
    pdf.setTextColor(0, 0, 0);

    // Insert cached bar image
    const barImage = cachedBarImages[i];
    pdf.addImage(barImage, 'PNG', xPos, yPos + 10, 160, 20); // Wider and taller bars
    }

    // After all trees, add a summary page with pie chart
    pdf.addPage();
    pdf.setFontSize(14);
    pdf.setFont("helvetica","bold");
    pdf.text("Summary of All Recommended Trees",40,60);
    pdf.setFont("helvetica","normal");
    pdf.setFontSize(10);
    pdf.text("Overall contribution breakdown across all recommended planting locations:",40,80);

    const summaryChart = await generateSummaryChart(plantedTrees);
    pdf.addImage(summaryChart, 'PNG', 40, 100, 300,300);

    pdf.save('Treefolio_Planting_Priority.pdf');
}


async function generateTreeChartCanvas(treeData) {
    const canvas = document.createElement('canvas');
    canvas.width = 200;
    canvas.height = 100; 
    const ctx = canvas.getContext('2d');

    const labels = ['School', 'Tree', 'Facility', 'Street', 'Heat'];
    const values = [
        treeData._schoolmean || 0,
        treeData._treemean || 0,
        treeData._facilitymean || 0,
        treeData._streetmean || 0,
        treeData._mean || 0
    ];

    return new Promise((resolve, reject) => {
        new Chart(ctx, {
            type: 'bar',
            data: {
                labels: labels,
                datasets: [{
                    label: 'Contribution',
                    data: values,
                    backgroundColor: ['red', 'green', 'blue', 'purple', 'orange']
                }]
            },
            options: {
                responsive: false,
                animation: false,
                scales: {
                    y: { beginAtZero: true }
                },
                plugins: {
                    legend: { display: false },
                    title: {
                        display: true,
                        text: 'Score Breakdown',
                        font: { size: 10 }
                    }
                }
            }
        });

        // Allow chart to render
        setTimeout(() => {
            resolve(canvas);
        }, 500);
    });
}

function updateTreeScoreBarForPDF(treeData, container) {
    const totalScore = treeData._combinedMean;
    const scoreParts = {
        school: treeData._schoolmean,
        tree: treeData._treemean,
        facility: treeData._facilitymean,
        street: treeData._streetmean,
        heat: treeData._mean
    };

    // Clear container
    container.innerHTML = '';

    Object.entries(scoreParts).forEach(([key, value]) => {
        if (value === undefined) return;
        
        const color = getColorForKey(key);
        const div = document.createElement('div');
        div.style.backgroundColor = color;
        div.style.width = `${(value / totalScore) * 100}%`;
        div.style.height = '100%';
        div.style.position = 'relative';
        div.style.color = 'black';
        div.style.fontSize = '8px';
        div.style.display = 'flex';
        div.style.flexDirection = 'column';
        div.style.justifyContent = 'center';
        div.style.alignItems = 'center';
        div.style.borderRight = '1px solid #fff';

        const labelText = capitalizeFirstLetter(key);
        const percentText = formatPercentage(value, totalScore);

        const labelSpan = document.createElement('span');
        labelSpan.style.fontSize = '8px';
        labelSpan.textContent = labelText;

        const percentSpan = document.createElement('span');
        percentSpan.style.fontSize = '8px';
        percentSpan.textContent = percentText;

        div.appendChild(labelSpan);
        div.appendChild(percentSpan);

        container.appendChild(div);
    });
}

function createBarHTML(treeData) {
    const total = treeData._combinedMean;
    const scoreParts = {
        school: treeData._schoolmean,
        tree: treeData._treemean,
        facility: treeData._facilitymean,
        street: treeData._streetmean,
        heat: treeData._mean
    };

    let html = `<div id="pdfBarContainer" style="display:flex; align-items:center; position:relative; height:20px;">`;

    // Filter out undefined values
    const validParts = Object.entries(scoreParts).filter(([key, value]) => value !== undefined);

    // Separate positive and negative values
    const positiveTotal = validParts.reduce((sum, [, value]) => sum + Math.max(0, value), 0);
    const negativeTotal = validParts.reduce((sum, [, value]) => sum + Math.abs(Math.min(0, value)), 0);
    const overallTotal = positiveTotal + negativeTotal;

    // Normalize percentages so they add up to 100%
    validParts.forEach(([key, value], idx) => {
        const normalizedPerc = (Math.abs(value) / overallTotal) * 100;
        const color = getColorForKeyAndValue(key, value);
        const sign = value < 0 ? "-" : "+"; // Indicate negative or positive
        const lbl = `${capitalizeFirstLetter(key)} ${sign}${normalizedPerc.toFixed(1)}%`;

        // Add bar segment
        html += `<div class="barSegment" 
                    style="width:${normalizedPerc}%; background-color:${color}; height:100%; display:flex; align-items:center; justify-content:center; position:relative;">`;

        // Add text inside or outside the bar based on width
        if (normalizedPerc >= 5) {
            // Place text inside if bar is large enough
            html += `<span style="font-size:10px; color:black; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">${lbl}</span>`;
        }
        html += `</div>`;

        // Add label outside the bar for small segments
        if (normalizedPerc < 5) {
            html += `<span style="font-size:10px; color:black; position:absolute; left:${idx * 10}px; top:25px;">${lbl}</span>`;
        }
    });

    html += `</div>`;
    return html;
}


async function generateSummaryChart(plantedTrees) {
    const sums = {school:0, tree:0, facility:0, street:0, heat:0};
    plantedTrees.forEach(t => {
        if (t._schoolmean) sums.school += t._schoolmean;
        if (t._treemean) sums.tree += t._treemean;
        if (t._facilitymean) sums.facility += t._facilitymean;
        if (t._streetmean) sums.street += t._streetmean;
        if (t._mean) sums.heat += t._mean;
    });

    const canvas = document.createElement('canvas');
    canvas.width = 300;
    canvas.height = 300;
    document.body.appendChild(canvas);
    canvas.style.position = 'absolute';
    canvas.style.left = '-9999px';

    const data = {
        labels: ['School', 'Tree', 'Facility', 'Street', 'Heat'],
        datasets: [{
            data: [sums.school, sums.tree, sums.facility, sums.street, sums.heat],
            backgroundColor: ['cornflowerblue','forestgreen','chocolate','darkviolet','darkorange']
        }]
    };

    return new Promise((resolve) => {
        const ctx = canvas.getContext('2d');
        new Chart(ctx, {
            type: 'pie',
            data: data,
            options: {
                animation: false,
                plugins: {
                    legend: { position: 'bottom' },
                    title: {
                        display: true,
                        text: 'Overall Contribution Breakdown',
                        font: { size: 14 }
                    }
                }
            }
        });
        setTimeout(async ()=>{
            const chartImg = await html2canvas(canvas, {scale:2}).then(c=> c.toDataURL('image/png'));
            document.body.removeChild(canvas);
            resolve(chartImg);
        },500);
    });
}


function getBoroughNameAndDistrict(boroCode) {
    if (boroCode.length < 3) return "Unknown Borough and District";

    const boroNum = parseInt(boroCode.charAt(0));
    const distNum = parseInt(boroCode.slice(1));

    let boroughName;
    switch (boroNum) {
        case 1: boroughName = "Manhattan"; break;
        case 2: boroughName = "The Bronx"; break;
        case 3: boroughName = "Brooklyn"; break;
        case 4: boroughName = "Queens"; break;
        case 5: boroughName = "Staten Island"; break;
        default: boroughName = "Unknown Borough";
    }

    return `${boroughName} Community District ${distNum < 10 ? '0' + distNum : distNum}`;
}

function formatPercentage(value, total) {
    if (total === 0 || value === undefined) return "0%";
    return Math.round((value / total) * 100) + "%";
}

function getColorForKeyAndValue(key, val) {
    // Different base colors for each key, tinted green if positive, red if negative
    const baseColors = {
        school: [100, 149, 237], // cornflowerblue
        tree: [34, 139, 34],    // forestgreen
        facility: [210, 105, 30], // chocolate
        street: [148, 0, 211],  // darkviolet
        heat: [255, 140, 0]     // darkorange
    };
    const color = baseColors[key] || [128,128,128];
    // If negative, shift towards red
    // if (val < 0) {
    //     return `rgb(${Math.min(color[0]+100,255)}, ${Math.max(color[1]-100,0)}, ${Math.max(color[2]-100,0)})`;
    // } else {
    //     // If positive, lighten color slightly
        return `rgb(${Math.min(color[0]+50,255)}, ${Math.min(color[1]+50,255)}, ${Math.min(color[2]+50,255)})`;
    // }
}

function formatPercentage(value, total) {
    if (total === 0 || value === undefined) return "0%";
    return Math.round((value / total) * 100) + "%";
}


function updateTreeScoreBarOriginal1(treeData, scoreBarContainer) {
    const totalScore = treeData._combinedMean;
    const scoreParts = {
        school: treeData._schoolmean,
        tree: treeData._treemean,
        facility: treeData._facilitymean,
        street: treeData._streetmean,
        heat: treeData._mean
    };

    console.log(scoreParts);

    for (const [key, value] of Object.entries(scoreParts)) {
        if (value === undefined) {
            continue;
        }

        const percentage = (value / totalScore) * 100;
        const color = getColorForKey(key);
        const barPart = document.createElement('div');
        barPart.style.backgroundColor = color;
        barPart.style.width = `${percentage}%`;
        barPart.style.height = '50%';
        barPart.style.position = 'relative';
        barPart.style.textAlign = 'center';
        barPart.style.color = 'black';
        barPart.style.fontSize = '4px'; // Adjust font size as needed
        barPart.innerHTML = `<span style="font-size: 4px;">${capitalizeFirstLetter(key)}</span>${Math.round(percentage)}%`;
        scoreBarContainer.appendChild(barPart);
    }
}

function flashOtherBoroughs(selectedBorough) {
    // Iterate through the borough features and set the flash state
    map.getSource('boroughs').setData(map.getSource('boroughs')._data); // Ensure the source data is updated

    map.querySourceFeatures('boroughs').forEach(feature => {
        const boroughId = feature.properties.boro_cd;
        if (boroughId != selectedBorough) {
            map.setFeatureState({ source: 'boroughs', id: feature.id || feature.properties.id }, { flash: true });
        } else {
            map.setFeatureState({ source: 'boroughs', id: feature.id || feature.properties.id }, { flash: false });
        }
    });

    setTimeout(() => {
        resetBoroughColors(selectedBorough);
    }, 1000);
}

function resetBoroughColors(selectedBorough) {
    map.querySourceFeatures('boroughs').forEach(feature => {
        map.setFeatureState({ source: 'boroughs', id: feature.id || feature.properties.id }, { flash: false });
    });
}



async function generateTreeGraph(treeData) {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    canvas.width = 400;
    canvas.height = 300;

    const data = {
        labels: ['School', 'Tree', 'Facility', 'Street', 'Heat'],
        datasets: [{
            label: 'Scores',
            data: [
                treeData._schoolmean,
                treeData._treemean,
                treeData._facilitymean,
                treeData._streetmean,
                treeData._mean
            ],
            backgroundColor: 'rgba(0, 123, 255, 0.5)',
            borderColor: 'rgba(0, 123, 255, 1)',
            borderWidth: 1
        }]
    };

    new Chart(ctx, {
        type: 'line',
        data: data,
        options: {
            scales: {
                y: {
                    beginAtZero: true
                }
            }
        }
    });

    return canvas;
}


mapboxgl.accessToken = 'pk.eyJ1IjoicnlhbmhsZXdpcyIsImEiOiJjbDhkcWZzcHowbGhiM3VrOWJ3ZmtzcnZyIn0.ipWAZK-oipctMjaHytOUKQ';

        var map = new mapboxgl.Map({
            container: 'map',
            style: 'mapbox://styles/mapbox/light-v10',
            center: [-73.930188, 40.642935],
            zoom: 13,
            preserveDrawingBuffer: true // Add this line

        });

        // load in treefolio84.geojson to originalGeoJsonData
        

        map.on('load', function () {

            map.addSource('boroughs', {
                type: 'geojson',
                // data: 'boroboundaries.geojson' // Replace with the path to your GeoJSON file
                // boroboundaries_with_id.geojson
                data: 'boroboundaries_with_id.geojson'
            });

            // Add a layer to display the boroughs
            map.addLayer({
                id: 'boroughs',
                type: 'fill',
                source: 'boroughs',
                paint: {
                    // 'fill-color': '#888888',
                    'fill-opacity': 0
                }
            });

            // Add a layer for the borough borders
            map.addLayer({
                id: 'borough-borders',
                type: 'line',
                source: 'boroughs',
                paint: {
                    'line-color': '#000000',
                    'line-width': 2
                }
            });

// Add this layer for flashing effect in the Mapbox 'load' event
map.addLayer({
    id: 'boroughs-flash',
    type: 'fill',
    source: 'boroughs',
    paint: {
        'fill-color': ['case',
            ['boolean', ['feature-state', 'flash'], false],
            '#ffffff', // White color for flashing
            'rgba(0,0,0,0)' // Transparent for the selected borough
        ],
        'fill-opacity': ['case',
            ['boolean', ['feature-state', 'flash'], false],
            1, // Fully opaque for flashing
            0 // Fully transparent for the selected borough
        ]
    }
});

            map.on('mousemove', 'boroughs', function(e) {
    if (e.features.length > 0) {
        var selectedBorough = document.getElementById('boroSelect').getAttribute('data-current');
        var hoveredBorough = e.features[0].properties.boro_cd;

        if (hoveredStateId !== null) {
            map.setFeatureState({ source: 'boroughs', id: hoveredStateId }, { hover: false });
        }

        if (selectedBorough !== hoveredBorough.toString()) {
            hoveredStateId = e.features[0].id;
            map.setFeatureState({ source: 'boroughs', id: hoveredStateId }, { hover: true });
        } else {
            hoveredStateId = null; // Reset if the hovered borough is the selected one
        }
    }
});

map.on('click', 'boroughs', function(e) {
    var selectedBorough = e.features[0].properties.boro_cd;

    // document.getElementById('boroSelect').setAttribute('data-current', selectedBorough);
    document.getElementById('boroSelect').value = selectedBorough;
    switchBorough();
    map.fitBounds(turf.bbox(e.features[0]));

    if (hoveredStateId !== null) {
        map.setFeatureState({ source: 'boroughs', id: hoveredStateId }, { hover: false });
    }
    hoveredStateId = e.features[0].id;
    map.setFeatureState({ source: 'boroughs', id: hoveredStateId }, { hover: true });
});

map.on('mouseleave', 'boroughs', function() {
    if (hoveredStateId !== null) {
        map.setFeatureState({ source: 'boroughs', id: hoveredStateId }, { hover: false });
    }
    hoveredStateId = null;
});

// Disable hover for the selected borough
map.on('mouseenter', 'boroughs', function(e) {
    var selectedBorough = document.getElementById('boroSelect').getAttribute('data-current');
    var hoveredBorough = e.features[0].properties.boro_cd;

    if (selectedBorough === hoveredBorough.toString()) {
        map.getCanvas().style.cursor = 'grab';
    } else {
        map.getCanvas().style.cursor = 'pointer';
    }
});

map.on('mouseleave', 'boroughs', function() {
    map.getCanvas().style.cursor = '';
});


            // Add feature state for hover effect
            map.addLayer({
                id: 'boroughs-hover',
                type: 'fill',
                source: 'boroughs',
                layout: {},
                paint: {
                    'fill-color': '#627BC1',
                    'fill-opacity': ['case', ['boolean', ['feature-state', 'hover'], false], 0.6, 0]
                }
            });

            var hoveredStateId = null;

            // Add your GeoJSON source for tree markers
            map.addSource('treeMarkers', {
                type: 'geojson',
                data: {
                    type: 'FeatureCollection',
                    features: []
                },
                cluster: false // Ensure clustering is disabled

            });

            // Add a layer to display the tree markers
            // map.addLayer({
            //     id: 'treeMarkers',
            //     type: 'circle',
            //     source: 'treeMarkers',
            //     paint: {
            //         'circle-radius': 5,
            //         'circle-color': '#ADD8E6',
            //         // green instead
            //         'circle-color': '#008000',
            //         'circle-opacity': 0.8
            //     }
            // });
            map.loadImage(
            './custom_marker.png',
            (error, image) => {
                if (error) throw error;
                map.addImage('custom-marker', image);
            });
            // map.addLayer({
            //     id: 'treeMarkers',
            //     type: 'symbol',
            //     source: 'treeMarkers',
            //     layout: {
            //         'icon-image': 'custom-marker',
            //         "icon-allow-overlap": true,
            //         "icon-size": 0.5,
            //     },
            //     cluster: false

            // });

            map.addLayer({
                id: 'treeMarkers',
                type: 'symbol',
                source: 'treeMarkers',
                layout: {
                    'icon-image': 'custom-marker',
                    "icon-allow-overlap": true,
                    "icon-size": ['get', 'iconSize'],
                },
                paint: {
                    'icon-color': ['get', 'iconColor']
                },
                cluster: false
            });

            // Add your GeoJSON source
            map.addSource('plantableAreas', {
                type: 'geojson',
                data: 'inputStreet.geojson'
            });

            // Add a layer to use the image to represent the data.
            map.addLayer({
                id: 'plantableAreas',
                type: 'fill',
                source: 'plantableAreas',
                layout: {},
                paint: {
                    'fill-color': [
                        'case',
                        ['==', ['get', 'canopy_type'], 'plantable'],
                        ['get', 'color'],
                        '#ffffff'
                    ],
                    'fill-opacity': 0.5
                }
            });

            map.addSource('schoolLayer', {
    type: 'geojson',
    data: {
        type: 'FeatureCollection',
        features: []
    }
});

map.addSource('treeLayer', {
    type: 'geojson',
    data: {
        type: 'FeatureCollection',
        features: []
    }
});

map.addLayer({
    id: 'schoolLayer',
    type: 'circle',
    source: 'schoolLayer',
    paint: {
        'circle-radius': 5,
        'circle-color': '#FF0000',
        'circle-opacity': 0.8
    }
});

// map.addLayer({
//     id: 'treeLayer',
//     type: 'circle',
//     source: 'treeLayer',
//     paint: {
//         'circle-radius': 5,
//         'circle-color': '#00FF00',
//         'circle-opacity': 0.8
//     }
// });

map.addLayer({
    id: 'treeLayer',
    type: 'symbol',
    source: 'treeLayer',
    layout: {
        'icon-image': 'marker-15', // Default marker
        'icon-size': 1.0
    }
});


map.addSource('treesLayer', {
        type: 'geojson',
        data: {
            type: 'FeatureCollection',
            features: []
        }
    });

    map.addLayer({
        id: 'treesLayer',
        type: 'circle',
        source: 'treesLayer',
        paint: {
            'circle-radius': 5,
            'circle-color': '#00FF00',
            'circle-opacity': 0.8
        }
    });

 // Add source for facilities
 map.addSource('facilityLayer', {
        type: 'geojson',
        data: {
            type: 'FeatureCollection',
            features: []
        }
    });

    // Add layer for facilities
    map.addLayer({
        id: 'facilityLayer',
        type: 'circle',
        source: 'facilityLayer',
        paint: {
            'circle-radius': 5,
            'circle-color': '#0000FF', // Blue color
            'circle-opacity': 0.8
        }
    });

    // Facility radius circle layer
    map.addSource('facilityCirclesLayer', {
        type: 'geojson',
        data: {
            type: 'FeatureCollection',
            features: []
        }
    });

    map.addLayer({
        id: 'facilityCirclesLayer',
        type: 'line',
        source: 'facilityCirclesLayer',
        paint: {
            'line-color': '#0000FF', // Blue color
            'line-width': 2
        }
    });

// Add source for streets
map.addSource('streetLayer', {
    type: 'geojson',
    data: {
        type: 'FeatureCollection',
        features: []
    }
});

map.addLayer({
    id: 'streetLayer',
    type: 'line',
    source: 'streetLayer',
    paint: {
        'line-color': 'gray',
        'line-width': 2,
        'line-opacity': 0.7
    }
});

map.addSource('streetBuffersLayer', {
    type: 'geojson',
    data: {
        type: 'FeatureCollection',
        features: []
    }
});

map.addLayer({
    id: 'streetBuffersLayer',
    type: 'fill',
    source: 'streetBuffersLayer',
    paint: {
        'fill-color': 'blue',
        'fill-opacity': 0.2
    }
});

    document.getElementById('treeToggleView').addEventListener('change', toggleTreeSettings);
    document.getElementById('treeRadiusToggle').addEventListener('change', toggleTreeRadius);


    // Add event listeners for school settings
    document.getElementById('schoolHeatingEffect').addEventListener('change', updatePlantableAreaColors);
    document.getElementById('schoolHeatingDistance').addEventListener('change', function() {
        updateSchoolHeatingDistance();
        updatePlantableAreaColors();
    });
    document.getElementById('schoolToggleView').addEventListener('change', toggleSchoolSettings);
    document.getElementById('schoolRadiusToggle').addEventListener('change', toggleSchoolRadius);
            // Call the function to update tree planting parameters
            // updateTreePlanting();
        });

        var currentGeoJsonLayer = null;

        // Make a layer for the trees, schools, and facilities using Mapbox GL JS
        // var newLayer = new mapboxgl.LayerGroup(); // Initialize with an empty layer group
        

        function displayGeoJson(geojsonData) {
            if (map.getSource('plantableAreas')) {
        map.getSource('plantableAreas').setData(geojsonData);
    } else {
        console.error('Source "plantableAreas" is not defined');
    }
        }

        function updateTreePlanting() {
    var totalTrees = parseInt(document.getElementById('totalTrees').value);
    var coolingEffect = parseFloat(document.getElementById('coolingEffect').value);
    var coolingDistance = parseInt(document.getElementById('coolingDistance').value);

    // Clear existing tree markers
    clearMapLayers();

    let schoolEffect = parseFloat(document.getElementById('schoolHeatingEffect').value);
    let schoolDistance = parseInt(document.getElementById('schoolHeatingDistance').value);
    let treeEffect = parseFloat(document.getElementById('treeCoolingEffect').value);
    let treeDistance = parseInt(document.getElementById('treeCoolingDistance').value);
    let facilityEffect = parseFloat(document.getElementById('facilityHeatingEffect').value);
    let facilityDistance = parseInt(document.getElementById('facilityHeatingDistance').value);
    let streetEffect = parseFloat(document.getElementById('streetEffect').value);
    let streetBufferDistance = parseInt(document.getElementById('streetBufferDistance').value);
    let streetWeightField = document.getElementById('streetWeightField').value;

    PlantTrees(originalGeoJsonData, totalTrees, coolingEffect, coolingDistance, schoolEffect, schoolDistance, treeEffect, treeDistance, facilityEffect, facilityDistance, streetEffect, streetBufferDistance, streetWeightField);

    document.getElementById('exportButton').style.display = 'block';

}


        function clearMapLayers() {
    console.log('Clearing map layers');

    schoolCircles.forEach(function(schoolCircle) {
        console.log('Removing school circle layer:', schoolCircle);
        if (map.getLayer(schoolCircle.id)) {
            map.removeLayer(schoolCircle.id);
        }
        if (map.getSource(schoolCircle.id)) {
            map.removeSource(schoolCircle.id);
        }

        const pointId = 'schoolPoint_' + schoolCircle.id;
        if (map.getLayer(pointId)) {
            map.removeLayer(pointId);
        }
        if (map.getSource(pointId)) {
            map.removeSource(pointId);
        }
    });

    schoolCircles = [];
}

        function clearPlantedTrees() {
                // Clear the treeMarkers source
    if (map.getSource('treeMarkers')) {
        map.getSource('treeMarkers').setData({
            type: 'FeatureCollection',
            features: []
        });
    }

    plantedTrees = [];
    currentTreeIndex = 0;

            document.getElementById('results').innerText = 'Cleared all planted trees.';
        
            document.getElementById('exportButton').style.display = 'none';

        }


        function calculateCentroid(geometry) {
            let centroid = [0, 0];
            let totalPoints = 0;

            if (geometry.type === "Polygon") {
                geometry.coordinates[0].forEach(coord => {
                    centroid[0] += coord[0]; // longitude
                    centroid[1] += coord[1]; // latitude
                    totalPoints++;
                });
            } else if (geometry.type === "MultiPolygon") {
                geometry.coordinates.forEach(polygon => {
                    let polygonCentroid = [0, 0];
                    let polygonPoints = 0;
                    polygon[0].forEach(coord => { // Only using the first ring
                        polygonCentroid[0] += coord[0];
                        polygonCentroid[1] += coord[1];
                        polygonPoints++;
                    });
                    centroid[0] += polygonCentroid[0] / polygonPoints; // Average for this polygon
                    centroid[1] += polygonCentroid[1] / polygonPoints;
                    totalPoints += 1; // We're averaging centroids, so each polygon counts as one "point"
                });
            }

            centroid[0] /= totalPoints; // Final average
            centroid[1] /= totalPoints;
            return [centroid[1], centroid[0]]; // Mapbox uses [lat, lng] format
        }

        function PlantTrees(originalGeoJsonData, totalTrees, coolingEffect, coolingDistance, schoolEffect, schoolDistance, treeEffect, treeDistance, facilityEffect, facilityDistance, streetEffect, streetBufferDistance, streetWeightField) {
    
            // clear existing tree markers
            clearPlantedTrees();
    
            let geojsonData = JSON.parse(JSON.stringify(originalGeoJsonData));

    // Apply effects from schools, trees, facilities, and streets
    geojsonData = applySchoolEffect(geojsonData, schoolEffect, schoolDistance);
    geojsonData = applyTreeEffect(geojsonData, treeEffect, treeDistance);
    geojsonData = applyFacilityEffect(geojsonData, facilityEffect, facilityDistance);
    geojsonData = applyStreetEffect(geojsonData, streetEffect, streetBufferDistance, streetWeightField);

    let plantableAreas = geojsonData.features.filter(feature => feature.properties.canopy_type === 'plantable');

    let treesPlanted = 0;

    while (treesPlanted < totalTrees && plantableAreas.length > 0) {
        // Calculate the combined mean for each plantable area
        plantableAreas.forEach(area => {
            area.properties._combinedMean = (area.properties._mean || 0) + 
                                             (area.properties._schoolmean || 0) + 
                                             (area.properties._treemean || 0) + 
                                             (area.properties._facilitymean || 0) + 
                                             (area.properties._streetmean || 0);
        });

        // Sort plantable areas by _combinedMean property in descending order
        plantableAreas.sort((a, b) => b.properties._combinedMean - a.properties._combinedMean);

        const plantingArea = plantableAreas[0];
        const centroid = calculateCentroid(plantingArea.geometry);

        // placeTreeOnMap(centroid);
        placeTreeOnMap(centroid, {
            _combinedMean: plantingArea.properties._combinedMean,
            _schoolmean: plantingArea.properties._schoolmean,
            _treemean: plantingArea.properties._treemean,
            _facilitymean: plantingArea.properties._facilitymean,
            _streetmean: plantingArea.properties._streetmean,
            _mean: plantingArea.properties._mean
        });
        treesPlanted++;

        // Apply cooling effect to the planted area if applicable
        if (coolingEffect > 0) {
            plantingArea.properties._treemean = (plantingArea.properties._treemean || 0) - coolingEffect;
            plantingArea.properties._displayMean = (plantingArea.properties._mean || 0) + 
                                                    (plantingArea.properties._schoolmean || 0) + 
                                                    (plantingArea.properties._treemean || 0) + 
                                                    (plantingArea.properties._facilitymean || 0) + 
                                                    (plantingArea.properties._streetmean || 0);
        }

        // Filter and adjust remaining plantable areas considering cooling effect and distance
        plantableAreas = plantableAreas.slice(1).filter(area => {
            const areaCentroid = calculateCentroid(area.geometry);
            const distance = getDistance(centroid[0], centroid[1], areaCentroid[0], areaCentroid[1]);
            if (coolingDistance > 0 && distance <= coolingDistance && coolingEffect > 0) {
                area.properties._treemean = (area.properties._treemean || 0) - coolingEffect * (coolingDistance - distance) / coolingDistance;
                area.properties._displayMean = (area.properties._mean || 0) + 
                                               (area.properties._schoolmean || 0) + 
                                               (area.properties._treemean || 0) + 
                                               (area.properties._facilitymean || 0) + 
                                               (area.properties._streetmean || 0);
            }
            return area.properties._combinedMean > 0;
        });
    }

    if (treesPlanted < totalTrees) {
        console.log(`Planted ${treesPlanted} trees. Ran out of suitable planting areas.`);
        document.getElementById('results').innerText = `Planted ${treesPlanted} trees. Ran out of suitable planting areas.`;
    } else {
        console.log(`Successfully planted all ${totalTrees} trees.`);
        document.getElementById('results').innerText = `Successfully planted all ${totalTrees} trees.`;
    }

    if (document.getElementById('plantingViewToggle').checked) {
        calculateMinMaxMean(geojsonData);
        updateMeanColors(geojsonData);
        displayGeoJson(geojsonData);
    }

    if (treesPlanted > 0) {
        showTreePopup(-1);
    }
}


        // function placeTreeOnMap(centroid) {
        //     const treeMarkerSource = map.getSource('treeMarkers');
        //     const newFeature = {
        //         type: 'Feature',
        //         geometry: {
        //             type: 'Point',
        //             coordinates: [centroid[1], centroid[0]]
        //         },
        //         properties: {}
        //     };

        //     const data = treeMarkerSource._data; // Access the current data
        //     data.features.push(newFeature); // Add the new feature
        //     treeMarkerSource.setData(data); // Update the source with the new data
        // }


        var plantedTrees = [];
var currentTreeIndex = 0;

function placeTreeOnMap(centroid, treeData) {
    const treeMarkerSource = map.getSource('treeMarkers');
    const newFeature = {
        type: 'Feature',
        geometry: {
            type: 'Point',
            coordinates: [centroid[1], centroid[0]]
        },
        // properties: treeData
        properties: {
            ...treeData,
            iconSize: 0.5,
            iconColor: '#008000' // Original color for unselected markers
        }
    };

    const data = treeMarkerSource._data; // Access the current data
    data.features.push(newFeature); // Add the new feature
    treeMarkerSource.setData(data); // Update the source with the new data

    // Store the tree data
    plantedTrees.push(treeData);
}

function showTreeMenu() {
    document.getElementById('treeNumberInput').style.display = 'block';
    document.getElementById('treeTitle').style.display = 'none';
    document.getElementById('leftArrow').style.display = 'none';
    document.getElementById('rightArrow').style.display = 'none';
    document.getElementById('homeButton').style.display = 'none';
}

function hideTreeMenu() {
    document.getElementById('treeNumberInput').style.display = 'none';
    document.getElementById('treeTitle').style.display = 'block';
    document.getElementById('leftArrow').style.display = 'block';
    document.getElementById('rightArrow').style.display = 'block';
    document.getElementById('homeButton').style.display = 'block';
}

function jumpToTree() {
    var treeNumber = parseInt(document.getElementById('treeNumberInput').value);
    if (treeNumber > 0 && treeNumber <= plantedTrees.length) {
        showTreePopup(treeNumber - 1);
    }
    hideTreeMenu();
}

function updateTreeMarkers(selectedIndex) {
    const treeMarkerSource = map.getSource('treeMarkers');
    const features = treeMarkerSource._data.features;

    features.forEach((feature, index) => {
        if (index === selectedIndex) {
            feature.properties.iconSize = 1.0;
            feature.properties.iconColor = '#000000'; // Darker color for the selected marker
        } else {
            feature.properties.iconSize = 0.5;
            feature.properties.iconColor = '#008000'; // Original color for unselected markers
        }
    });

    treeMarkerSource.setData({
        type: 'FeatureCollection',
        features: features
    });

}
function showTreePopup(index) {

    if(index < 0) {
        index = plantedTrees.length - 1;
        const treeData = plantedTrees[index];
        document.getElementById('treeTitle').innerText = `Tree Tool - Use this to navigate planted trees!`;
        document.getElementById('treeTitle').style.width = '100%';
        document.getElementById('treePopup').style.display = 'block';
        document.getElementById('homeButton').style.display = 'block';
        document.getElementById('treeScoreBar').style.width = '0px';
        currentTreeIndex = index;
        return;
    }

    const treeData = plantedTrees[index];
    document.getElementById('treeTitle').innerText = `Tree #${index + 1}`;

    // Create a canvas for the score bar
    const scoreBarContainer = document.getElementById('treeScoreBar');
    scoreBarContainer.innerHTML = ''; // Clear any previous content
    const scoreBarCanvas = document.createElement('canvas');
    scoreBarCanvas.width = 300;
    scoreBarCanvas.height = 50;
    scoreBarContainer.appendChild(scoreBarCanvas);
    
    const scoreBarContext = scoreBarCanvas.getContext('2d');
    updateTreeScoreBarOriginal(treeData);

    document.getElementById('treeTitle').style.width = '50px';
    document.getElementById('treeScoreBar').style.width = '300px';
    document.getElementById('treePopup').style.display = 'block';
    document.getElementById('leftArrow').style.color = index === 0 ? 'white' : 'black';
    document.getElementById('rightArrow').style.color = index === plantedTrees.length - 1 ? 'white' : 'black';
    document.getElementById('homeButton').style.display = 'block';
    currentTreeIndex = index;

    updateTreeMarkers(index);

    // Zoom to the selected tree
    const coordinates = map.getSource('treeMarkers')._data.features[index].geometry.coordinates;
    map.flyTo({ center: coordinates, zoom: 15 });
}



function updateTreeScoreBarOriginal(treeData) {
    const scoreBar = document.getElementById('treeScoreBar');
    scoreBar.innerHTML = '';

    const totalScore = treeData._combinedMean;
    const scoreParts = {
        school: treeData._schoolmean,
        tree: treeData._treemean,
        facility: treeData._facilitymean,
        street: treeData._streetmean,
        heat: treeData._mean
    };

    console.log(scoreParts);

    for (const [key, value] of Object.entries(scoreParts)) {
        if(value == undefined) {
            continue;
        }

        const percentage = (value / totalScore) * 100;
        const color = getColorForKeyAndValue(key, value);
        const barPart = document.createElement('div');
        barPart.style.backgroundColor = color;
        barPart.style.width = `${percentage}%`;
        barPart.innerText = `${Math.round(percentage)}%`;
        barPart.style.position = 'relative';
        barPart.style.color = 'black';
        barPart.innerHTML = `<span style="position: absolute; top: -20px; width: 100%; text-align: center; font-size: 10px; color: black;">${capitalizeFirstLetter(key)}</span>${Math.round(percentage)}%`;
        scoreBar.appendChild(barPart);
    }
}

function updateTreeScoreBar(treeData, context) {
    const totalScore = treeData._combinedMean;
    const scoreParts = {
        school: treeData._schoolmean,
        tree: treeData._treemean,
        facility: treeData._facilitymean,
        street: treeData._streetmean,
        heat: treeData._mean
    };

    const barWidth = context.canvas.width;
    const barHeight = context.canvas.height;
    let xOffset = 0;

    context.font = '10px Arial';
    context.textAlign = 'center';
    context.textBaseline = 'middle';

    for (const [key, value] of Object.entries(scoreParts)) {
        if (value === undefined) {
            continue;
        }

        const percentage = (value / totalScore);
        const width = barWidth * percentage;
        const color = getColorForKey(key);

        context.fillStyle = color;
        context.fillRect(xOffset, 0, width, barHeight);

        context.fillStyle = 'black';
        context.fillText(`${Math.round(percentage * 100)}%`, xOffset + width / 2, barHeight / 2);
        context.fillText(capitalizeFirstLetter(key), xOffset + width / 2, barHeight / 2 - 10);

        xOffset += width;
    }
}

function capitalizeFirstLetter(string) {
    return string.charAt(0).toUpperCase() + string.slice(1);
}

function getColorForKey(key) {
    switch (key) {
        case 'school': return 'red';
        case 'tree': return 'green';
        case 'facility': return 'blue';
        case 'street': return 'purple';
        case 'heat': return 'orange';
        default: return 'black';
    }
}

function navigateTree(direction) {
    const newIndex = currentTreeIndex + direction;
    if (newIndex >= 0 && newIndex < plantedTrees.length) {
        showTreePopup(newIndex);
    }
}


        function getDistance(lat1, lon1, lat2, lon2) {
            var R = 6371e3; // Earth's radius in meters
            var φ1 = lat1 * Math.PI / 180;
            var φ2 = lat2 * Math.PI / 180;
            var Δφ = (lat2 - lat1) * Math.PI / 180;
            var Δλ = (lon2 - lon1) * Math.PI / 180;

            var a = Math.sin(Δφ / 2) * Math.sin(Δφ / 2) +
                    Math.cos(φ1) * Math.cos(φ2) *
                    Math.sin(Δλ / 2) * Math.sin(Δλ / 2);
            var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

            return R * c; // in meters
        }

        function getColor(heatIndex, scale) {
            console.log("max and min mean", maxMean, minMean);
            const range = maxMean - minMean;
            const normalizedIndex = (heatIndex - minMean) / range;
            const scaledIndex = Math.pow(normalizedIndex, scale);

            // Interpolate between green (0), orange (0.5), and red (1)
            if (scaledIndex < 0.5) {
                // Mix between green and orange
                const mix = scaledIndex * 2;
                return mixColor('#008000', '#ff8c00', mix);
            } else {
                // Mix between orange and red
                const mix = (scaledIndex - 0.5) * 2;
                return mixColor('#ff8c00', '#ff0000', mix);
            }
        }

        var showHeatIndex = false;
        var heatIndexScale = 1;

        function toggleHeatIndex() {
            showHeatIndex = document.getElementById('heatIndexToggle').checked;
            console.log("Show heat index:", showHeatIndex);
            document.getElementById('heatIndexSettings').style.display = showHeatIndex ? 'block' : 'none';
            updatePlantableAreaColors();
        }

        function mixColor(color1, color2, weight) {
            var color1Rgb = hexToRgb(color1),
                color2Rgb = hexToRgb(color2),
                r = Math.round(mix(color1Rgb.r, color2Rgb.r, weight)),
                g = Math.round(mix(color1Rgb.g, color2Rgb.g, weight)),
                b = Math.round(mix(color1Rgb.b, color2Rgb.b, weight));
            return rgbToHex(r, g, b);
        }

        function mix(start, end, weight) {
            return start + (end - start) * weight;
        }

        function hexToRgb(hex) {
            var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : null;
        }

        function rgbToHex(r, g, b) {
            return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
        }

        var originalGeoJsonData;

        var minMean, maxMean;

        function calculateMinMaxMean(geojsonData) {
            var means = geojsonData.features.map(feature => {
                if (feature.properties.canopy_type === 'plantable') {
                    return feature.properties._displayMean;
                }
            }).filter(mean => mean !== undefined);

            minMean = Math.min(...means);
            maxMean = Math.max(...means);
            if (minMean === maxMean) {
                minMean = 0;
                maxMean = 1;
            }
            if (minMean === Infinity) {
                minMean = 0;
                maxMean = 1;
            }
            console.log("Calculated min and max mean values:", minMean, maxMean);
        }

        function drawLinesToClosestSchoolFromLayer() {
            originalGeoJsonData.features.forEach(plantableArea => {
                if (plantableArea.properties.canopy_type === 'plantable') {
                    const plantableCentroid = calculateCentroid(plantableArea.geometry);

                    let closestSchoolPoint = null;
                    let minDistance = Infinity;

                    schoolLayer.eachLayer(function(layer) {
                        let schoolPoint;
                        if (layer.feature && layer.feature.geometry) {
                            if (layer.feature.geometry.type === 'MultiPoint') {
                                const firstPointCoords = layer.feature.geometry.coordinates[0];
                                schoolPoint = [firstPointCoords[1], firstPointCoords[0]]; // Correct [lat, lng] order for Mapbox
                            } else {
                                schoolPoint = [layer.feature.geometry.coordinates[1], layer.feature.geometry.coordinates[0]];
                            }
                        } else if (layer.getLatLng) {
                            let latLng = layer.getLatLng();
                            schoolPoint = [latLng.lat, latLng.lng];
                        } else {
                            console.log('Unknown layer type or geometry not defined');
                            return;
                        }

                        const distance = getDistance(plantableCentroid[0], plantableCentroid[1], schoolPoint[0], schoolPoint[1]);
                        if (distance < minDistance) {
                            closestSchoolPoint = schoolPoint;
                            minDistance = distance;
                        }
                    });

                    if (closestSchoolPoint) {
                        map.addLayer({
                            id: 'line' + Math.random(),
                            type: 'line',
                            source: {
                                type: 'geojson',
                                data: {
                                    type: 'Feature',
                                    geometry: {
                                        type: 'LineString',
                                        coordinates: [
                                            [plantableCentroid[1], plantableCentroid[0]],
                                            closestSchoolPoint
                                        ]
                                    }
                                }
                            },
                            layout: {
                                'line-join': 'round',
                                'line-cap': 'round'
                            },
                            paint: {
                                'line-color': 'blue',
                                'line-width': 1,
                                'line-opacity': 0.5
                            }
                        });
                    }
                }
            });
        }

        function updatePlantableAreaColors() {
    // Clone the original GeoJSON data to avoid modifying it directly
    let geojsonData = JSON.parse(JSON.stringify(originalGeoJsonData));

    // Apply the necessary effects
    let schoolEffect = parseFloat(document.getElementById('schoolHeatingEffect').value);
    let schoolDistance = parseInt(document.getElementById('schoolHeatingDistance').value);
    let treeEffect = parseFloat(document.getElementById('treeCoolingEffect').value);
    let treeDistance = parseInt(document.getElementById('treeCoolingDistance').value);
    let facilityEffect = parseFloat(document.getElementById('facilityHeatingEffect').value);
    let facilityDistance = parseInt(document.getElementById('facilityHeatingDistance').value);
    let streetEffect = parseFloat(document.getElementById('streetEffect').value);
    let streetBufferDistance = parseInt(document.getElementById('streetBufferDistance').value);
    let streetWeightField = document.getElementById('streetWeightField').value;

    geojsonData = applySchoolEffect(geojsonData, schoolEffect, schoolDistance);
    geojsonData = applyTreeEffect(geojsonData, treeEffect, treeDistance);
    geojsonData = applyFacilityEffect(geojsonData, facilityEffect, facilityDistance);
    geojsonData = applyStreetEffect(geojsonData, streetEffect, streetBufferDistance, streetWeightField);

    // Calculate _displayMean based on the selected options and apply it to existing means
    geojsonData.features.forEach(feature => {
        if (feature.properties.canopy_type === 'plantable') {
            let currentMean = feature.properties._mean || 0;
            let schoolMean = feature.properties._schoolmean || 0;
            let treeMean = feature.properties._treemean || 0;
            let facilityMean = feature.properties._facilitymean || 0;
            let streetMean = feature.properties._streetmean || 0;

            if (document.getElementById('heatIndexToggle').checked) {
                feature.properties._displayMean = currentMean + schoolMean + treeMean + facilityMean + streetMean;
            } else {
                feature.properties._displayMean = schoolMean + treeMean + facilityMean + streetMean;
            }
        }
    });

    calculateMinMaxMean(geojsonData);
    updateMeanColors(geojsonData);
    displayGeoJson(geojsonData);
}




        function getMeanColor(mean) {
            const normalizedMean = (mean - minMean) / (maxMean - minMean);
            if (normalizedMean < 0.5) {
                const mix = normalizedMean * 2;
                return mixColor('#008000', '#ff8c00', mix);
            } else {
                const mix = (normalizedMean - 0.5) * 2;
                return mixColor('#ff8c00', '#ff0000', mix);
            }
        }

        function updateMeanColors(geojsonData) {
            geojsonData.features.forEach(feature => {
                if (feature.properties.canopy_type === 'plantable') {
                    const mean = feature.properties._displayMean;
                    feature.properties.color = getMeanColor(mean);
                }
            });
        }

        function applyFacilityEffect(geojsonData, facilityEffect, facilityDistance) {
    if (!document.getElementById('facilityToggleView').checked) {
        return geojsonData;
    }

    var effectType = document.querySelector('input[name="effectType"]:checked').value;
    var sigma = parseFloat(document.getElementById('gaussianSigma').value);
    var amplitude = parseFloat(document.getElementById('gaussianAmplitude').value);
    
    var facilityLayer = map.getSource('facilityLayer')._data;

    geojsonData.features.forEach(plantableArea => {
        if (plantableArea.properties.canopy_type === 'plantable') {
            const plantableCentroid = calculateCentroid(plantableArea.geometry);

            facilityLayer.features.forEach(facilityFeature => {
                const facilityPoint = facilityFeature.geometry.coordinates;

                const distance = getDistance(plantableCentroid[0], plantableCentroid[1], facilityPoint[1], facilityPoint[0]);
                if (effectType === 'binary') {
                    if (distance <= facilityDistance) {
                        if (!plantableArea.properties._facilitymean) {
                            plantableArea.properties._facilitymean = 0;
                        }
                        plantableArea.properties._facilitymean += facilityEffect;
                    }
                } else if (effectType === 'gaussian') {
                    var weight = gaussianWeight(distance, facilityDistance, sigma, amplitude);
                    if (!plantableArea.properties._facilitymean) {
                        plantableArea.properties._facilitymean = 0;
                    }
                    plantableArea.properties._facilitymean += facilityEffect * weight;
                }
            });
        }
    });
    return geojsonData;
}


        function applySchoolEffect(geojsonData, schoolEffect, schoolDistance) {
    if (!document.getElementById('schoolToggleView').checked) {
        return geojsonData;
    }

    var effectType = document.querySelector('input[name="effectType"]:checked').value;
    var sigma = parseFloat(document.getElementById('gaussianSigma').value);
    var amplitude = parseFloat(document.getElementById('gaussianAmplitude').value);
    
    var schoolLayer = map.getSource('schoolLayer')._data;

    geojsonData.features.forEach(plantableArea => {
        if (plantableArea.properties.canopy_type === 'plantable') {
            const plantableCentroid = calculateCentroid(plantableArea.geometry);

            schoolLayer.features.forEach(schoolFeature => {
                const schoolPoint = schoolFeature.geometry.coordinates;

                const distance = getDistance(plantableCentroid[0], plantableCentroid[1], schoolPoint[1], schoolPoint[0]);
                if (effectType === 'binary') {
                    if (distance <= schoolDistance) {
                        if (!plantableArea.properties._schoolmean) {
                            plantableArea.properties._schoolmean = 0;
                        }
                        plantableArea.properties._schoolmean += schoolEffect + Math.random() * 5;
                    }
                } else if (effectType === 'gaussian') {
                    var weight = gaussianWeight(distance, schoolDistance, sigma, amplitude);
                    if (!plantableArea.properties._schoolmean) {
                        plantableArea.properties._schoolmean = 0;
                    }
                    plantableArea.properties._schoolmean += schoolEffect * weight;
                }
            });
        }
    });
    return geojsonData;
}


        function gaussianWeight(distance, effectDistance, sigma, amplitude) {
            var z = distance / (effectDistance * sigma);
            return amplitude * Math.exp(-0.5 * z * z);
        }
   
        // Function to apply tree effect
function applyTreeEffect(geojsonData, treeEffect, treeDistance) {
    var effectType = document.querySelector('input[name="effectType"]:checked').value;
    var sigma = parseFloat(document.getElementById('gaussianSigma').value);
    var amplitude = parseFloat(document.getElementById('gaussianAmplitude').value);

    var plantableIndex = new RBush();
    geojsonData.features.forEach(function(feature) {
        if (feature.properties.canopy_type === 'plantable') {
            var bbox = turf.bbox(feature);
            plantableIndex.insert({
                minX: bbox[0],
                minY: bbox[1],
                maxX: bbox[2],
                maxY: bbox[3],
                feature: feature
            });
        }
    });

    var treeLayer = map.getSource('treesLayer')._data;

    treeLayer.features.forEach(function(treeFeature) {
        const treePoint = treeFeature.geometry.coordinates;
        const treePointGeoJSON = turf.point(treePoint);
        const boundingBox = turf.bbox(turf.circle(treePointGeoJSON, treeDistance, { units: 'meters' }));

        var plantablesInRange = plantableIndex.search({
            minX: boundingBox[0],
            minY: boundingBox[1],
            maxX: boundingBox[2],
            maxY: boundingBox[3]
        });

        plantablesInRange.forEach(function(plantable) {
            var feature = plantable.feature;
            var areaCentroid = turf.centroid(feature).geometry.coordinates;

            var distance = turf.distance(treePointGeoJSON, turf.point(areaCentroid), { units: 'meters' });

            if (effectType === 'binary') {
                if (distance <= treeDistance) {
                    if (!feature.properties._treemean) {
                        feature.properties._treemean = 0;
                    }
                    feature.properties._treemean -= treeEffect;
                }
            } else if (effectType === 'gaussian') {
                var weight = gaussianWeight(distance, treeDistance, sigma, amplitude);
                if (!feature.properties._treemean) {
                    feature.properties._treemean = 0;
                }
                feature.properties._treemean -= treeEffect * weight;
            }
        });
    });

    return geojsonData;
}
var treeCircles = [];

function toggleTreeData() {
    var treeDataVisible = document.getElementById('treeToggleView').checked;
    var showTreeRadius = document.getElementById('treeRadiusToggle').checked;

    if (treeDataVisible) {
        $.getJSON(`./borosTrees/boro_cd_${document.getElementById('boroSelect').value}.geojson`, function(data) {
            map.getSource('treesLayer').setData(data);

            const treeFeatures = [];
            const circleFeatures = [];
            treeCircles = [];

            data.features.forEach(feature => {
                const [lng, lat] = [feature.properties.longitude, feature.properties.Latitude];
                console.log('Adding tree:', lng, lat);

                // Add tree point feature
                treeFeatures.push({
                    type: 'Feature',
                    geometry: {
                        type: 'Point',
                        coordinates: [lng, lat]
                    },
                    properties: {}
                });

                // Add tree cooling effect circle feature
                if (showTreeRadius) {
                    const coolingDistance = parseInt(document.getElementById('treeCoolingDistance').value);
                    const effectCircle = turf.circle([lng, lat], coolingDistance, { units: 'meters' });
                    const circleId = 'treesCircle_' + lng + '_' + lat;

                    treeCircles.push({
                        id: circleId,
                        coordinates: [lng, lat]
                    });

                    circleFeatures.push({
                        type: 'Feature',
                        geometry: effectCircle.geometry,
                        properties: {}
                    });
                }
            });

            // Update treesLayer with all tree points
            map.getSource('treesLayer').setData({
                type: 'FeatureCollection',
                features: treeFeatures
            });

            // Update or add circlesLayer with all cooling effect circles
            if (showTreeRadius) {
                if (map.getSource('circlesLayer')) {
                    map.getSource('circlesLayer').setData({
                        type: 'FeatureCollection',
                        features: circleFeatures
                    });
                } else {
                    map.addSource('circlesLayer', {
                        type: 'geojson',
                        data: {
                            type: 'FeatureCollection',
                            features: circleFeatures
                        }
                    });

                    map.addLayer({
                        id: 'circlesLayer',
                        type: 'line',
                        source: 'circlesLayer',
                        paint: {
                            'line-color': '#008000', // Green color
                            'line-width': 2
                        }
                    });
                }
            } else if (map.getSource('circlesLayer')) {
                // Hide circles layer if not showing tree radius
                map.getSource('circlesLayer').setData({
                    type: 'FeatureCollection',
                    features: []
                });
            }

            updatePlantableAreaColors();
        });
    } else {
        if (map.getSource('treesLayer')) {
            map.getSource('treesLayer').setData({
                type: 'FeatureCollection',
                features: []
            });
        }
        if (map.getSource('circlesLayer')) {
            map.getSource('circlesLayer').setData({
                type: 'FeatureCollection',
                features: []
            });
        }

        updatePlantableAreaColors();
    }
}


// Function to toggle tree radius visibility
function toggleTreeRadius() {
    var showTreeRadius = document.getElementById('treeRadiusToggle').checked;
    if (showTreeRadius) {
        toggleTreeData();
    } else {
        if (map.getSource('circlesLayer')) {
            map.getSource('circlesLayer').setData({
                type: 'FeatureCollection',
                features: []
            });
        }
    }
}



document.getElementById('treeToggleView').addEventListener('change', toggleTreeSettings);
document.getElementById('treeRadiusToggle').addEventListener('change', toggleTreeRadius);


function toggleTreeSettings() {
    toggleTreeData();
    var treeSettings = document.getElementById('treeSettings');
    var treeToggle = document.getElementById('treeToggleView').checked;
    treeSettings.style.display = treeToggle ? "block" : "none";
}


function toggleFacilityData() {
    var facilityDataVisible = document.getElementById('facilityToggleView').checked;
    var showFacilityRadius = document.getElementById('facilityRadiusToggle').checked;
    if (facilityDataVisible) {
        $.getJSON(`./borosFacilities/boro_cd_${document.getElementById('boroSelect').value}.geojson`, function(data) {
            map.getSource('facilityLayer').setData(data);

            const facilityFeatures = [];
            const facilityCircleFeatures = [];
            facilityCircles = [];

            data.features.forEach(feature => {
                // const [lng, lat] = feature.geometry.coordinates;
                // lng is feature.properties.LONGITUDE and lat is feature.properties.LATITUDE
                const [lng, lat] = [feature.properties.LONGITUDE, feature.properties.LATITUDE];
                facilityFeatures.push({
                    type: 'Feature',
                    geometry: {
                        type: 'Point',
                        coordinates: [lng, lat]
                    },
                    properties: {}
                });

                if (showFacilityRadius) {
                    const heatingDistance = parseInt(document.getElementById('facilityHeatingDistance').value);
                    const effectCircle = turf.circle([lng, lat], heatingDistance, { units: 'meters' });
                    const circleId = 'facilityCircle_' + lng + '_' + lat;

                    facilityCircles.push({
                        id: circleId,
                        coordinates: [lng, lat]
                    });

                    facilityCircleFeatures.push({
                        type: 'Feature',
                        geometry: effectCircle.geometry,
                        properties: {}
                    });
                }
            });

            map.getSource('facilityLayer').setData({
                type: 'FeatureCollection',
                features: facilityFeatures
            });

            if (showFacilityRadius) {
                if (map.getSource('facilityCirclesLayer')) {
                    map.getSource('facilityCirclesLayer').setData({
                        type: 'FeatureCollection',
                        features: facilityCircleFeatures
                    });
                } else {
                    map.addSource('facilityCirclesLayer', {
                        type: 'geojson',
                        data: {
                            type: 'FeatureCollection',
                            features: facilityCircleFeatures
                        }
                    });

                    map.addLayer({
                        id: 'facilityCirclesLayer',
                        type: 'line',
                        source: 'facilityCirclesLayer',
                        paint: {
                            'line-color': '#0000FF', // Blue color
                            'line-width': 2
                        }
                    });
                }
            } else if (map.getSource('facilityCirclesLayer')) {
                map.getSource('facilityCirclesLayer').setData({
                    type: 'FeatureCollection',
                    features: []
                });
            }

            updatePlantableAreaColors();
        });
    } else {
        if (map.getSource('facilityLayer')) {
            map.getSource('facilityLayer').setData({
                type: 'FeatureCollection',
                features: []
            });
        }
        if (map.getSource('facilityCirclesLayer')) {
            map.getSource('facilityCirclesLayer').setData({
                type: 'FeatureCollection',
                features: []
            });
        }

        updatePlantableAreaColors();
    }
}

function toggleFacilityRadius() {
    var showFacilityRadius = document.getElementById('facilityRadiusToggle').checked;
    if (showFacilityRadius) {
        toggleFacilityData();
    } else {
        if (map.getSource('facilityCirclesLayer')) {
            map.getSource('facilityCirclesLayer').setData({
                type: 'FeatureCollection',
                features: []
            });
        }
    }
}

function toggleFacilitySettings() {
    toggleFacilityData();
    var facilitySettings = document.getElementById('facilitySettings');
    var facilityToggle = document.getElementById('facilityToggleView').checked;
    facilitySettings.style.display = facilityToggle ? "block" : "none";
}
// Function to update the radius of existing facility circles
function updateFacilityHeatingDistance() {
    const heatingDistance = parseInt(document.getElementById('facilityHeatingDistance').value);

    const updatedCircleFeatures = [];

    facilityCircles.forEach(circle => {
        const coordinates = circle.coordinates;
        const effectCircle = turf.circle(coordinates, heatingDistance, { units: 'meters' });

        updatedCircleFeatures.push({
            type: 'Feature',
            geometry: effectCircle.geometry,
            properties: {}
        });
    });

    if (map.getSource('facilityCirclesLayer')) {
        map.getSource('facilityCirclesLayer').setData({
            type: 'FeatureCollection',
            features: updatedCircleFeatures
        });
    }
    
    updatePlantableAreaColors();
}

// Event listener for the heating distance change
document.getElementById('facilityHeatingDistance').addEventListener('change', function() {
    updateFacilityHeatingDistance();
    updatePlantableAreaColors();
});



        function toggleGaussianSettings() {
            var effectType = document.querySelector('input[name="effectType"]:checked').value;
            var gaussianSettings = document.getElementById('gaussianSettings');
            gaussianSettings.style.display = effectType === 'gaussian' ? 'block' : 'none';
        }

        document.getElementById('heatIndexScale').addEventListener('input', updatePlantableAreaColors);
        document.querySelectorAll('input[name="effectType"]').forEach(function(radio) {
            radio.addEventListener('change', updatePlantableAreaColors);
        });

        document.getElementById('gaussianSigma').addEventListener('change', updatePlantableAreaColors);
        document.getElementById('gaussianAmplitude').addEventListener('change', updatePlantableAreaColors);

        document.getElementById('schoolHeatingEffect').addEventListener('change', updatePlantableAreaColors);
        document.getElementById('schoolHeatingDistance').addEventListener('change', function() {
            updatePlantableAreaColors();
        });

        document.getElementById('treeCoolingDistance').addEventListener('change', function() {
    updateTreeCoolingDistance();
    updatePlantableAreaColors();
});

document.getElementById('treeCoolingEffect').addEventListener('change', updatePlantableAreaColors);

document.getElementById('treeToggleView').addEventListener('change', updatePlantableAreaColors);


        document.getElementById('heatIndexScale').addEventListener('input', updatePlantableAreaColors);
        document.getElementById('schoolToggleView').addEventListener('change', updatePlantableAreaColors);

        document.getElementById('plantingViewToggle').addEventListener('change', function() {
            updateTreePlanting();
            if (!document.getElementById('plantingViewToggle').checked) {
                updatePlantableAreaColors();
            }
        });

        document.getElementById('facilityHeatingEffect').addEventListener('change', updatePlantableAreaColors);
        document.getElementById('facilityHeatingDistance').addEventListener('change', function() {
            updatePlantableAreaColors();
        });
        document.getElementById('facilityToggleView').addEventListener('change', updatePlantableAreaColors);

        document.getElementById('streetEffect').addEventListener('change', updatePlantableAreaColors);
        document.getElementById('streetBufferDistance').addEventListener('change', function() {
            updatePlantableAreaColors();
        });
        document.getElementById('streetWeightField').addEventListener('change', updatePlantableAreaColors);

        var boroughPattern = /boro_cd_(\d+)\.geojson/;


        const boroughFiles = [
    'boro_cd_104.geojson',
    'boro_cd_105.geojson',
    'boro_cd_106.geojson',
    'boro_cd_107.geojson',
    'boro_cd_109.geojson',
    'boro_cd_110.geojson',
    'boro_cd_111.geojson',
    'boro_cd_112.geojson',
    'boro_cd_164.geojson',
    'boro_cd_201.geojson',
    'boro_cd_202.geojson',
    'boro_cd_203.geojson',
    'boro_cd_204.geojson',
    'boro_cd_205.geojson',
    'boro_cd_206.geojson',
    'boro_cd_207.geojson',
    'boro_cd_226.geojson',
    'boro_cd_228.geojson',
    'boro_cd_301.geojson',
    'boro_cd_302.geojson',
    'boro_cd_303.geojson',
    'boro_cd_304.geojson',
    'boro_cd_306.geojson',
    'boro_cd_308.geojson',
    'boro_cd_310.geojson',
    'boro_cd_314.geojson',
    'boro_cd_402.geojson',
    'boro_cd_403.geojson',
    'boro_cd_404.geojson',
    'boro_cd_409.geojson',
    'boro_cd_480.geojson',
    'boro_cd_481.geojson',
    'boro_cd_482.geojson',
    'boro_cd_483.geojson',
    'boro_cd_484.geojson',
    'boro_cd_595.geojson',
    'boro_cd_NULL.geojson'
];

function loadBoroughOptions() {
    boroughFiles.forEach(filename => {
        const match = filename.match(boroughPattern);
        if (match) {
            const boroughCode = match[1];
            const option = $("<option>").val(boroughCode).text("Borough " + boroughCode);
            $("#boroSelect").append(option);
        }
    });

    // Trigger the initial borough switch after loading options
    switchBorough();
}


        async function loadGeoJson(url) {
    return new Promise((resolve, reject) => {
        $.getJSON(url, function(data) {
            resolve(data);
        }).fail(function() {
            reject(new Error('Failed to load GeoJSON data'));
        });
    });
}

async function switchBorough() {
    var selectedBorough = document.getElementById('boroSelect').value;
    var currentBorough = document.getElementById('boroSelect').getAttribute('data-current');

    if (selectedBorough === currentBorough) {
        return;
    }

    clearPlantedTrees();
    clearMapLayers();

    document.getElementById('boroSelect').setAttribute('data-current', selectedBorough);

    try {
        const [boroughData, schoolData, facilityData, streetData] = await Promise.all([
            loadGeoJson(`./boros/boro_cd_${selectedBorough}.geojson`),
            loadGeoJson(`./borosSchools/boro_cd_${selectedBorough}.geojson`),
            loadGeoJson(`./borosFacilities/boro_cd_${selectedBorough}.geojson`),
            loadGeoJson(`./borosStreets/boro_cd_${selectedBorough}.geojson`) // Load street data
        ]);

        originalGeoJsonData = boroughData;
        calculateMinMaxMean(originalGeoJsonData);
        displayGeoJson(originalGeoJsonData);
        updatePlantableAreaColors();
        zoomToBorough(boroughData);

        // Handle school data
        if (map.getSource('schoolLayer')) {
            map.setLayoutProperty('schoolLayer', 'visibility', 'none');
            map.getSource('schoolLayer').setData(schoolData);
        }

        if (document.getElementById('schoolToggleView').checked) {
            createSchoolCircles(schoolData);
            toggleSchoolRadius();
        }

        // Handle tree data
        if (map.getSource('treesLayer') && document.getElementById('treeToggleView').checked) {
            const treeData = await loadGeoJson(`./borosTrees/boro_cd_${selectedBorough}.geojson`);
            map.getSource('treesLayer').setData(treeData);

            const treeFeatures = [];
            const circleFeatures = [];
            const showTreeRadius = document.getElementById('treeRadiusToggle').checked;
            treeCircles = [];

            treeData.features.forEach(feature => {
                const [lng, lat] = [feature.properties.longitude, feature.properties.Latitude];

                treeFeatures.push({
                    type: 'Feature',
                    geometry: {
                        type: 'Point',
                        coordinates: [lng, lat]
                    },
                    properties: {}
                });

                if (showTreeRadius) {
                    const coolingDistance = parseInt(document.getElementById('treeCoolingDistance').value);
                    const effectCircle = turf.circle([lng, lat], coolingDistance, { units: 'meters' });
                    const circleId = 'treesCircle_' + lng + '_' + lat;

                    treeCircles.push({
                        id: circleId,
                        coordinates: [lng, lat]
                    });

                    circleFeatures.push({
                        type: 'Feature',
                        geometry: effectCircle.geometry,
                        properties: {}
                    });
                }
            });

            map.getSource('treesLayer').setData({
                type: 'FeatureCollection',
                features: treeFeatures
            });

            if (showTreeRadius) {
                if (map.getSource('circlesLayer')) {
                    map.getSource('circlesLayer').setData({
                        type: 'FeatureCollection',
                        features: circleFeatures
                    });
                } else {
                    map.addSource('circlesLayer', {
                        type: 'geojson',
                        data: {
                            type: 'FeatureCollection',
                            features: circleFeatures
                        }
                    });

                    map.addLayer({
                        id: 'circlesLayer',
                        type: 'line',
                        source: 'circlesLayer',
                        paint: {
                            'line-color': '#008000',
                            'line-width': 2
                        }
                    });
                }
            } else if (map.getSource('circlesLayer')) {
                map.getSource('circlesLayer').setData({
                    type: 'FeatureCollection',
                    features: []
                });
            }
        }

        // Handle facility data
        if (map.getSource('facilityLayer') && document.getElementById('facilityToggleView').checked) {
            map.getSource('facilityLayer').setData(facilityData);

            const facilityFeatures = [];
            const circleFeatures = [];
            const showFacilityRadius = document.getElementById('facilityRadiusToggle').checked;
            facilityCircles = [];

            facilityData.features.forEach(feature => {
                const [lng, lat] = [feature.properties.LONGITUDE, feature.properties.LATITUDE];

                facilityFeatures.push({
                    type: 'Feature',
                    geometry: {
                        type: 'Point',
                        coordinates: [lng, lat]
                    },
                    properties: {}
                });

                if (showFacilityRadius) {
                    const heatingDistance = parseInt(document.getElementById('facilityHeatingDistance').value);
                    const effectCircle = turf.circle([lng, lat], heatingDistance, { units: 'meters' });

                    facilityCircles.push({
                        coordinates: [lng, lat]
                    });

                    circleFeatures.push({
                        type: 'Feature',
                        geometry: effectCircle.geometry,
                        properties: {}
                    });
                }
            });

            map.getSource('facilityLayer').setData({
                type: 'FeatureCollection',
                features: facilityFeatures
            });

            if (showFacilityRadius) {
                map.getSource('facilityCirclesLayer').setData({
                    type: 'FeatureCollection',
                    features: circleFeatures
                });
            } else {
                map.getSource('facilityCirclesLayer').setData({
                    type: 'FeatureCollection',
                    features: []
                });
            }
        } else if (map.getSource('facilityLayer')) {
            map.getSource('facilityLayer').setData({
                type: 'FeatureCollection',
                features: []
            });
            map.getSource('facilityCirclesLayer').setData({
                type: 'FeatureCollection',
                features: []
            });
        }

        // Handle street data
        if (map.getSource('streetsLayer')) {
            map.removeLayer('streetsLayer');
            map.removeSource('streetsLayer');
        }

        if (map.getSource('streetBuffersLayer')) {
            map.removeLayer('streetBuffersLayer');
            map.removeSource('streetBuffersLayer');
        }

        if (document.getElementById('streetToggleView').checked) {
            loadStreets().then(() => {
                const showStreetBuffer = document.getElementById('streetBufferToggle').checked;
                toggleStreetBuffer(showStreetBuffer); // Ensure buffer visibility matches toggle state
            });
        }


    } catch (error) {
        console.error('Error loading data:', error);
    }
}





        function zoomToBorough(geojsonData) {
        var bounds = turf.bbox(geojsonData);
        map.fitBounds([[bounds[0], bounds[1]], [bounds[2], bounds[3]]]); // Correct order: [latitude, longitude]
    }

// Define an array to store school circles and their IDs
var schoolCircles = [];

function createSchoolCircles(data) {
    const heatingDistance = parseInt(document.getElementById('schoolHeatingDistance').value);
    const showSchoolRadius = document.getElementById('schoolRadiusToggle').checked;

    data.features.forEach(feature => {
        const coordinates = feature.geometry.coordinates;
        console.log('Creating circle for school with coordinates:', coordinates);
        const effectCircle = turf.circle(coordinates, heatingDistance, { units: 'meters' });
        const circleId = coordinates.join('_');

        if (map.getSource(circleId)) {
            map.getSource(circleId).setData(effectCircle);
        } else {
            schoolCircles.push({
                id: circleId,
                data: effectCircle
            });

            map.addSource(circleId, {
                type: 'geojson',
                data: effectCircle
            });

            map.addLayer({
                id: circleId,
                type: 'line',
                source: circleId,
                paint: {
                    'line-color': 'red',
                    'line-width': 2,
                    'line-opacity': 1
                },
                layout: {
                    'visibility': showSchoolRadius ? 'visible' : 'none'
                }
            });

            const pointId = 'schoolPoint_' + circleId;
            if (map.getSource(pointId)) {
                map.getSource(pointId).setData({
                    type: 'Feature',
                    geometry: {
                        type: 'Point',
                        coordinates: coordinates
                    }
                });
            } else {
                map.addSource(pointId, {
                    type: 'geojson',
                    data: {
                        type: 'Feature',
                        geometry: {
                            type: 'Point',
                            coordinates: coordinates
                        }
                    }
                });

                map.addLayer({
                    id: pointId,
                    type: 'circle',
                    source: pointId,
                    paint: {
                        'circle-radius': 5,
                        'circle-color': 'red',
                        'circle-opacity': 1
                    }
                });
            }
        }
    });
}
function updateTreeCoolingDistance() {
    var coolingDistance = parseInt(document.getElementById('treeCoolingDistance').value);
    var showTreeRadius = document.getElementById('treeRadiusToggle').checked;

    // Remove existing circles
    if (map.getSource('circlesLayer')) {
        map.removeLayer('circlesLayer');
        map.removeSource('circlesLayer');
    }

    const circleFeatures = [];

    treeCircles.forEach(circle => {
        var coordinates = circle.coordinates;
        var effectCircle = turf.circle(coordinates, coolingDistance, { units: 'meters' });

        circleFeatures.push({
            type: 'Feature',
            geometry: effectCircle.geometry,
            properties: {}
        });
    });

    if (showTreeRadius) {
        map.addSource('circlesLayer', {
            type: 'geojson',
            data: {
                type: 'FeatureCollection',
                features: circleFeatures
            }
        });

        map.addLayer({
            id: 'circlesLayer',
            type: 'line',
            source: 'circlesLayer',
            paint: {
                'line-color': '#008000', // Green color for outline
                'line-width': 2
            },
            layout: {
                'visibility': showTreeRadius ? 'visible' : 'none'
            }
        });
    }

    updatePlantableAreaColors();
}




// Function to update the school heating distance
function updateSchoolHeatingDistance() {
    const heatingDistance = parseInt(document.getElementById('schoolHeatingDistance').value);

    schoolCircles.forEach(circle => {
        if (circle.id.startsWith('schoolPoint_')) return; // Skip school points
        const coordinates = circle.id.split('_').map(coord => parseFloat(coord));
        console.log('Updating circle ID:', circle.id, 'with coordinates:', coordinates);

        // Ensure the coordinates are in the correct format
        if (Array.isArray(coordinates) && coordinates.length === 2 && typeof coordinates[0] === 'number' && typeof coordinates[1] === 'number') {
            const effectCircle = turf.circle(coordinates, heatingDistance, { units: 'meters' });
            map.getSource(circle.id).setData(effectCircle);
        } else {
            console.error('Invalid coordinates for turf.circle:', coordinates);
        }
    });

    updatePlantableAreaColors();
}

function toggleSchoolData() {
    var schoolDataVisible = document.getElementById('schoolToggleView').checked;
    var selectedBorough = document.getElementById('boroSelect').value;

    if (schoolDataVisible) {
        // Fetch and add the school data for the selected borough
        map.setLayoutProperty('schoolLayer', 'visibility', 'visible');
        schoolCircles.forEach(circle => {
            map.setLayoutProperty(circle.id, 'visibility', 'visible');
            const pointId = 'schoolPoint_' + circle.id;
            map.setLayoutProperty(pointId, 'visibility', 'visible');
        });
        $.getJSON('borosSchools/boro_cd_' + selectedBorough + '.geojson', function(data) {
            createSchoolCircles(data);
            updatePlantableAreaColors();
        });
    } else {
        map.setLayoutProperty('schoolLayer', 'visibility', 'none');
        schoolCircles.forEach(circle => {
            map.setLayoutProperty(circle.id, 'visibility', 'none');
            const pointId = 'schoolPoint_' + circle.id;
            map.setLayoutProperty(pointId, 'visibility', 'none');
        });
    }
}


// Function to toggle school radius visibility
function toggleSchoolRadius() {
    const showSchoolRadius = document.getElementById('schoolRadiusToggle').checked;
    console.log('Toggling school radius visibility:', showSchoolRadius);

    schoolCircles.forEach(circle => {
        console.log('Setting visibility for circle ID:', circle.id);
        map.setLayoutProperty(circle.id, 'visibility', showSchoolRadius ? 'visible' : 'none');
    });
}

// Function to toggle school settings
function toggleSchoolSettings() {
    toggleSchoolData();
    const schoolSettings = document.getElementById('schoolSettings');
    const schoolToggle = document.getElementById('schoolToggleView').checked;
    schoolSettings.style.display = schoolToggle ? 'block' : 'none';
}

// Add event listeners
document.getElementById('schoolHeatingEffect').addEventListener('change', updatePlantableAreaColors);
document.getElementById('schoolHeatingDistance').addEventListener('change', function() {
    updateSchoolHeatingDistance();
    updatePlantableAreaColors();
});
document.getElementById('schoolToggleView').addEventListener('change', toggleSchoolSettings);
document.getElementById('schoolRadiusToggle').addEventListener('change', toggleSchoolRadius);

// Initialize borough options and event listener for borough change
loadBoroughOptions();
document.getElementById('boroSelect').addEventListener('change', switchBorough);

// // Ensure school data is shown when switching boroughs if school data toggle is enabled
// function switchBorough() {
//     var selectedBorough = document.getElementById('boroSelect').value;
//     var currentBorough = document.getElementById('boroSelect').getAttribute('data-current');

//     if (selectedBorough === currentBorough) {
//         return;
//     }

//     clearPlantedTrees();
//     clearMapLayers();

//     document.getElementById('boroSelect').setAttribute('data-current', selectedBorough);

//     $.getJSON('./boros/boro_cd_' + selectedBorough + '.geojson', function(data) {
//         originalGeoJsonData = data;
//         calculateMinMaxMean(originalGeoJsonData);
//         displayGeoJson(originalGeoJsonData);
//         updatePlantableAreaColors();
//         zoomToBorough(data);
//     });

//     $.getJSON('./borosSchools/boro_cd_' + selectedBorough + '.geojson', function(data) {
//         map.setLayoutProperty('schoolLayer', 'visibility', 'none');
//         map.getSource('schoolLayer').setData(data);
//         if (document.getElementById('schoolToggleView').checked) {
//             createSchoolCircles(data);
//         }
//     });
// }


function toggleStreetData() {
    const streetDataVisible = document.getElementById('streetToggleView').checked;
    const showStreetBuffer = document.getElementById('streetBufferToggle').checked;

    if (streetDataVisible) {
        if (map.getSource('streetsLayer')) {
            map.setLayoutProperty('streetsLayer', 'visibility', 'visible');
            toggleStreetBuffer(showStreetBuffer); // Handle buffer visibility
        } else {
            loadStreets().then(() => {
                const showStreetBuffer = document.getElementById('streetBufferToggle').checked;
                toggleStreetBuffer(showStreetBuffer); // Ensure buffer visibility matches toggle state
            });
        }
    } else {
        if (map.getSource('streetsLayer')) {
            map.setLayoutProperty('streetsLayer', 'visibility', 'none');
        }
        if (map.getSource('streetBuffersLayer')) {
            map.setLayoutProperty('streetBuffersLayer', 'visibility', 'none');
        }
    }
}



function loadStreets() {
    var selectedBorough = document.getElementById('boroSelect').value;

    return new Promise((resolve, reject) => {
        $.getJSON(`./borosStreets/boro_cd_${selectedBorough}.geojson`, function(data) {
            if (!map.getSource('streetsLayer')) {
                map.addSource('streetsLayer', {
                    type: 'geojson',
                    data: data
                });

                map.addLayer({
                    id: 'streetsLayer',
                    type: 'line',
                    source: 'streetsLayer',
                    paint: {
                        'line-color': 'gray',
                        'line-width': 2,
                        'line-opacity': 0.7
                    }
                });
            } else {
                map.getSource('streetsLayer').setData(data);
            }

            updateStreetBuffers(data); // Pass the data to the buffer update function
            resolve();
        }).fail(reject);
    });
}



function updateStreetBuffers(streetData) {
    if (!streetData) {
        streetData = map.getSource('streetsLayer')._data;
    }
    
    const bufferDistance = parseInt(document.getElementById('streetBufferDistance').value);
    const streetBuffers = [];

    streetData.features.forEach(feature => {
        const buffer = turf.buffer(feature, bufferDistance, { units: 'meters' });
        streetBuffers.push(buffer);
    });

    if (map.getSource('streetBuffersLayer')) {
        map.getSource('streetBuffersLayer').setData({
            type: 'FeatureCollection',
            features: streetBuffers
        });
        map.setLayoutProperty('streetBuffersLayer', 'visibility', 'visible');
    } else {
        map.addSource('streetBuffersLayer', {
            type: 'geojson',
            data: {
                type: 'FeatureCollection',
                features: streetBuffers
            }
        });

        map.addLayer({
            id: 'streetBuffersLayer',
            type: 'fill',
            source: 'streetBuffersLayer',
            paint: {
                'fill-color': 'blue',
                'fill-opacity': 0.2
            }
        });
    }
}





function toggleStreetBuffer(showBuffer) {
    map.setLayoutProperty('streetBuffersLayer', 'visibility', showBuffer ? 'visible' : 'none');
}

function applyStreetEffect(geojsonData, streetEffect, streetBufferDistance, streetWeightField) {
    if (!document.getElementById('streetToggleView').checked) {
        return geojsonData;
    }

    var plantableIndex = new RBush();
    geojsonData.features.forEach(function(feature) {
        if (feature.properties.canopy_type === 'plantable') {
            var bbox = turf.bbox(feature);
            plantableIndex.insert({
                minX: bbox[0],
                minY: bbox[1],
                maxX: bbox[2],
                maxY: bbox[3],
                feature: feature
            });
        }
    });

    var streetData = map.getSource('streetsLayer')._data;
    streetData.features.forEach(function(streetFeature) {
        var buffer = turf.buffer(streetFeature, streetBufferDistance, { units: 'meters' });
        var boundingBox = turf.bbox(buffer);

        var plantablesInRange = plantableIndex.search({
            minX: boundingBox[0],
            minY: boundingBox[1],
            maxX: boundingBox[2],
            maxY: boundingBox[3]
        });

        plantablesInRange.forEach(function(plantable) {
            var feature = plantable.feature;
            var intersection = turf.intersect(feature, buffer);

            if (intersection) {
                var streetWeight = streetFeature.properties[streetWeightField];
                streetWeight = isNaN(streetWeight) ? 0 : streetWeight;

                var effect = streetEffect * streetWeight;

                if (!feature.properties._streetmean) {
                    feature.properties._streetmean = 0;
                }
                feature.properties._streetmean += effect;
            }
        });
    });

    return geojsonData;
}





// Event listeners for street settings
document.getElementById('streetBufferDistance').addEventListener('change', function() {
    if (document.getElementById('streetToggleView').checked) {
        loadStreets();
    }
});
document.getElementById('streetEffect').addEventListener('change', updatePlantableAreaColors);
document.getElementById('streetWeightField').addEventListener('change', updatePlantableAreaColors);
document.getElementById('streetToggleView').addEventListener('change', toggleStreetSettings);
document.getElementById('streetBufferToggle').addEventListener('change', function() {
    toggleStreetBuffer(document.getElementById('streetBufferToggle').checked);
});

function toggleStreetSettings() {
    toggleStreetData();
    var streetSettings = document.getElementById('streetSettings');
    var streetToggle = document.getElementById('streetToggleView').checked;
    streetSettings.style.display = streetToggle ? "block" : "none";
}



        loadBoroughOptions();

        document.getElementById('boroSelect').addEventListener('change', switchBorough);
    </script>


</body>
</html>
